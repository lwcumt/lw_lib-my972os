
#include "port.h"




#include"pic_exec.h"

#include "key.h"

#include "io.h"


#include "sys.h"
#include "timer.h"
#include"drv_glcd.h"

#include "timer_config.h"


//
#define TIMER0_TICK_PER_SEC 20000

#define TIMER1_TICK_PER_SEC   5000  //10




#define TIMER2_TICK_PER_SEC 10
#define TIMER3_TICK_PER_SEC 10

//中断优先级
#define TIMER0_PRIORITY 3
#define TIMER1_PRIORITY 2
#define TIMER2_PRIORITY 4
#define TIMER3_PRIORITY 5
#define LED1DIR 1ul<<13
#define LED1ANTI 1ul<<13

Int32U MsTime;
char Ms_Flag,Temp11, sysflag;
unsigned  char chushihua,tmpzidong;


char flagone;
Int32U SysTime;
Int32U sys_tick;


unsigned long int dem;
unsigned char a,b,xa,xb,xa1,xb1,flagqianjin,flaghoutui,flaghq;
unsigned  long int  muqiancn,xsmuqiancn, yuandiancn;
unsigned char  chengxu_Flag,xianshi_Flag,flaglaba,daowei;
unsigned char keytingji,xz,xs,senor,flagqianjin2,flagsenor,flagyqjixian,flagyhjixian,flagyzjixian;
  int   chengxuTime,xianshitime,labatime;
//unsigned long int vbcd;

unsigned char  xsenor1;


//**************脉冲发送变量**********************//
 
Int32U Current_last;

Int32U MotorSpeed;
Int16U SpeedCou;

Int8U ToTargetStop_flag;

Int8U StopDelay_flag;
Int16U StopDelayCou;

Int8U CutEnBegin_flag;
Int16U CutDelayTime;

Int8U FreqMotorStop_flag;

unsigned char  flagbeep;
Int8U flagshoulun;

Int32U waitTemp[120];
Int8U LowerAC_SPD_flag;

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1000;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb1[]={
	0xD5D4, 0xDBAD, 0xE01A, 0xE391, 0xE65F, 0xE8AC, 0xEA99, 0xEC3D, 0xEDA3, 0xEEDC,  // 10
	0xEFEE, 0xF0E0, 0xF1B7, 0xF278, 0xF325, 0xF3C3, 0xF452, 0xF4D5, 0xF54D, 0xF5BC,  // 20
	0xF621, 0xF67F, 0xF6D7, 0xF728, 0xF774, 0xF7BC, 0xF7FE, 0xF83D, 0xF878, 0xF8B0,  // 30
	0xF8E4, 0xF915, 0xF944, 0xF971, 0xF99B, 0xF9C4, 0xF9EA, 0xFA0E, 0xFA31, 0xFA52,  // 40
	0xFA72, 0xFA91, 0xFAAE, 0xFACA, 0xFAE4, 0xFAFE, 0xFB17, 0xFB2F, 0xFB45, 0xFB5C,  // 50
	0xFB71, 0xFB85, 0xFB99, 0xFBAC, 0xFBBF, 0xFBD0, 0xFBE2, 0xFBF2, 0xFC02, 0xFC12,  // 60
	0xFC21, 0xFC30, 0xFC3E, 0xFC4C, 0xFC59, 0xFC66, 0xFC73, 0xFC7F, 0xFC8B, 0xFC97,  // 70
	0xFCA2, 0xFCAD, 0xFCB8, 0xFCC3, 0xFCCD, 0xFCD7, 0xFCE1, 0xFCEA, 0xFCF3, 0xFCFC,  // 80
	0xFD05, 0xFD0E, 0xFD16, 0xFD1E, 0xFD26, 0xFD2E, 0xFD36, 0xFD3D, 0xFD45, 0xFD4C,  // 90
	0xFD53, 0xFD5A, 0xFD60, 0xFD67, 0xFD6D, 0xFD74, 0xFD7A, 0xFD80, 0xFD86, 0xFD8C,  // 100
	0xFD91, 0xFD97, 0xFD9D, 0xFDA2, 0xFDA7, 0xFDAD, 0xFDB2, 0xFDB7, 0xFDBC, 0xFDC0,  // 110
	0xFDC5, 0xFDCA, 0xFDCE, 0xFDD3, 0xFDD7, 0xFDDC, 0xFDE0, 0xFDE4, 0xFDE8, 0xFDED // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1200;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb2[]={
	0xD5D4, 0xDCB3, 0xE1A6, 0xE566, 0xE854, 0xEAAD, 0xEC9C, 0xEE39, 0xEF97, 0xF0C3,  // 10
	0xF1C8, 0xF2AD, 0xF377, 0xF42A, 0xF4CA, 0xF55B, 0xF5DE, 0xF655, 0xF6C2, 0xF725,  // 20
	0xF781, 0xF7D5, 0xF824, 0xF86C, 0xF8B0, 0xF8EF, 0xF92A, 0xF961, 0xF995, 0xF9C6,  // 30
	0xF9F4, 0xFA20, 0xFA49, 0xFA70, 0xFA95, 0xFAB8, 0xFAD9, 0xFAF8, 0xFB17, 0xFB34,  // 40
	0xFB4F, 0xFB69, 0xFB82, 0xFB9B, 0xFBB2, 0xFBC8, 0xFBDD, 0xFBF2, 0xFC05, 0xFC18,  // 50
	0xFC2A, 0xFC3C, 0xFC4D, 0xFC5D, 0xFC6D, 0xFC7C, 0xFC8B, 0xFC99, 0xFCA7, 0xFCB5,  // 60
	0xFCC1, 0xFCCE, 0xFCDA, 0xFCE6, 0xFCF1, 0xFCFC, 0xFD07, 0xFD12, 0xFD1C, 0xFD26,  // 70
	0xFD30, 0xFD39, 0xFD42, 0xFD4B, 0xFD54, 0xFD5C, 0xFD64, 0xFD6C, 0xFD74, 0xFD7C,  // 80
	0xFD83, 0xFD8A, 0xFD92, 0xFD99, 0xFD9F, 0xFDA6, 0xFDAC, 0xFDB3, 0xFDB9, 0xFDBF,  // 90
	0xFDC5, 0xFDCB, 0xFDD0, 0xFDD6, 0xFDDB, 0xFDE1, 0xFDE6, 0xFDEB, 0xFDF0, 0xFDF5,  // 100
	0xFDFA, 0xFDFF, 0xFE03, 0xFE08, 0xFE0C, 0xFE11, 0xFE15, 0xFE19, 0xFE1D, 0xFE21,  // 110
	0xFE25, 0xFE29, 0xFE2D, 0xFE31, 0xFE35, 0xFE38, 0xFE3C, 0xFE40, 0xFE43, 0xFE46 // 120
	
};

/****
/////////////////////////////////////////////////////////////////////////
// 晶振频率=72MHz; 预分频率=4
// 参数设定值: V0 = 20; 折点1= 100; 折点2 = 1200 极限转速 = 1300 rpm
//         Point0= 0;第一折点= 12;第二折点= 100; 终点步数= 120
// 电机转动一周对应脉冲数=1000; 编程响应(CTn rewrite)补偿步数 = 8
/////////////////////////////////////////////////////////////////////////
unsigned int const waitTb1[]={
    0x61D4,0x8178,0x9690,0xA5A1,0xB0EE,0xB9B8,0xC0C0,0xC680,0xCB4C,0xCF5A, // 10
    0xD2D4,0xD82B,0xDC61,0xDFC9,0xE299,0xE4F5,0xE6F8,0xE8B3,0xEA35,0xEB89, // 20
    0xECB5,0xEDC1,0xEEB1,0xEF8A,0xF04F,0xF102,0xF1A6,0xF23C,0xF2C7,0xF347, // 30
    0xF3BE,0xF42C,0xF493,0xF4F4,0xF54E,0xF5A2,0xF5F2,0xF63D,0xF683,0xF6C6, // 40
    0xF705,0xF741,0xF77A,0xF7B0,0xF7E4,0xF815,0xF844,0xF870,0xF89B,0xF8C4, // 50
    0xF8EB,0xF911,0xF935,0xF957,0xF979,0xF999,0xF9B8,0xF9D5,0xF9F2,0xFA0D, // 60
    0xFA28,0xFA42,0xFA5B,0xFA73,0xFA8A,0xFAA0,0xFAB6,0xFACB,0xFAE0,0xFAF4, // 70
    0xFB07,0xFB1A,0xFB2C,0xFB3D,0xFB4F,0xFB5F,0xFB6F,0xFB7F,0xFB8F,0xFB9E, // 80
    0xFBAC,0xFBBA,0xFBC8,0xFBD6,0xFBE3,0xFBF0,0xFBFC,0xFC09,0xFC15,0xFC20, // 90
    0xFC2C,0xFC37,0xFC42,0xFC4C,0xFC57,0xFC61,0xFC6B,0xFC75,0xFC7E,0xFC82, // 100
    0xFC86,0xFC89,0xFC8D,0xFC90,0xFC94,0xFC97,0xFC9B,0xFC9E,0xFCA1,0xFCA5, // 110
    0xFCA8,0xFCAB,0xFCAF,0xFCB2,0xFCB5,0xFCB8,0xFCBB,0xFCBE,0xFCC2,0xFCC5
};**/

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1400;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb3[]={
    0xD5D4, 0xDDAB, 0xE313, 0xE703, 0xEA01, 0xEC5F, 0xEE47, 0xEFD9, 0xF12B, 0xF24A,  // 10
	0xF341, 0xF418, 0xF4D4, 0xF57B, 0xF610, 0xF695, 0xF70E, 0xF77A, 0xF7DD, 0xF838,  // 20
	0xF88B, 0xF8D7, 0xF91E, 0xF95F, 0xF99C, 0xF9D5, 0xFA09, 0xFA3B, 0xFA69, 0xFA95,  // 30
	0xFABE, 0xFAE4, 0xFB09, 0xFB2B, 0xFB4C, 0xFB6B, 0xFB88, 0xFBA4, 0xFBBF, 0xFBD9,  // 40
	0xFBF1, 0xFC08, 0xFC1E, 0xFC33, 0xFC48, 0xFC5B, 0xFC6E, 0xFC80, 0xFC91, 0xFCA2,  // 50
	0xFCB1, 0xFCC1, 0xFCD0, 0xFCDE, 0xFCEC, 0xFCF9, 0xFD06, 0xFD12, 0xFD1E, 0xFD2A,  // 60
	0xFD35, 0xFD40, 0xFD4B, 0xFD55, 0xFD5F, 0xFD69, 0xFD72, 0xFD7B, 0xFD84, 0xFD8D,  // 70
	0xFD95, 0xFD9D, 0xFDA5, 0xFDAD, 0xFDB5, 0xFDBC, 0xFDC3, 0xFDCA, 0xFDD1, 0xFDD7,  // 80
	0xFDDE, 0xFDE4, 0xFDEA, 0xFDF0, 0xFDF6, 0xFDFC, 0xFE02, 0xFE07, 0xFE0C, 0xFE12,  // 90
	0xFE17, 0xFE1C, 0xFE21, 0xFE26, 0xFE2A, 0xFE2F, 0xFE33, 0xFE38, 0xFE3C, 0xFE40,  // 100
	0xFE45, 0xFE49, 0xFE4D, 0xFE51, 0xFE55, 0xFE58, 0xFE5C, 0xFE60, 0xFE63, 0xFE67,  // 110
	0xFE6A, 0xFE6E, 0xFE71, 0xFE74, 0xFE77, 0xFE7B, 0xFE7E, 0xFE81, 0xFE84, 0xFE87 // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1600;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb4[]={
    0xD5D4, 0xDE9D, 0xE45A, 0xE86C, 0xEB76, 0xEDCF, 0xEFAE, 0xF135, 0xF278, 0xF389,  // 10
	0xF473, 0xF53D, 0xF5EE, 0xF689, 0xF714, 0xF78F, 0xF7FD, 0xF862, 0xF8BD, 0xF90F,  // 20
	0xF95B, 0xF9A1, 0xF9E1, 0xFA1D, 0xFA54, 0xFA87, 0xFAB7, 0xFAE3, 0xFB0D, 0xFB34,  // 30
	0xFB59, 0xFB7C, 0xFB9D, 0xFBBC, 0xFBD9, 0xFBF5, 0xFC0F, 0xFC28, 0xFC40, 0xFC57,  // 40
	0xFC6C, 0xFC81, 0xFC95, 0xFCA8, 0xFCBA, 0xFCCB, 0xFCDC, 0xFCEC, 0xFCFB, 0xFD0A,  // 50
	0xFD18, 0xFD26, 0xFD33, 0xFD40, 0xFD4C, 0xFD58, 0xFD63, 0xFD6E, 0xFD79, 0xFD83,  // 60
	0xFD8D, 0xFD97, 0xFDA0, 0xFDA9, 0xFDB2, 0xFDBB, 0xFDC3, 0xFDCB, 0xFDD3, 0xFDDB,  // 70
	0xFDE2, 0xFDE9, 0xFDF0, 0xFDF7, 0xFDFE, 0xFE04, 0xFE0B, 0xFE11, 0xFE17, 0xFE1D,  // 80
	0xFE22, 0xFE28, 0xFE2D, 0xFE33, 0xFE38, 0xFE3D, 0xFE42, 0xFE47, 0xFE4B, 0xFE50,  // 90
	0xFE54, 0xFE59, 0xFE5D, 0xFE61, 0xFE66, 0xFE6A, 0xFE6E, 0xFE72, 0xFE75, 0xFE79,  // 100
	0xFE7D, 0xFE80, 0xFE84, 0xFE87, 0xFE8B, 0xFE8E, 0xFE91, 0xFE95, 0xFE98, 0xFE9B,  // 110
	0xFE9E, 0xFEA1, 0xFEA4, 0xFEA7, 0xFEAA, 0xFEAC, 0xFEAF, 0xFEB2, 0xFEB4, 0xFEB7 // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1800;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb5[]={
    0xD5D4, 0xDF7B, 0xE58A, 0xE9B3, 0xECBD, 0xEF0F, 0xF0E1, 0xF259, 0xF390, 0xF494,  // 10
	0xF571, 0xF62F, 0xF6D5, 0xF766, 0xF7E7, 0xF85A, 0xF8C0, 0xF91D, 0xF971, 0xF9BD,  // 20
	0xFA03, 0xFA43, 0xFA7D, 0xFAB4, 0xFAE6, 0xFB15, 0xFB41, 0xFB69, 0xFB8F, 0xFBB3,  // 30
	0xFBD5, 0xFBF4, 0xFC12, 0xFC2E, 0xFC49, 0xFC62, 0xFC7A, 0xFC90, 0xFCA6, 0xFCBA,  // 40
	0xFCCE, 0xFCE1, 0xFCF2, 0xFD04, 0xFD14, 0xFD24, 0xFD33, 0xFD41, 0xFD4F, 0xFD5C,  // 50
	0xFD69, 0xFD75, 0xFD81, 0xFD8C, 0xFD97, 0xFDA2, 0xFDAC, 0xFDB6, 0xFDC0, 0xFDC9,  // 60
	0xFDD2, 0xFDDB, 0xFDE3, 0xFDEB, 0xFDF3, 0xFDFB, 0xFE02, 0xFE0A, 0xFE11, 0xFE17,  // 70
	0xFE1E, 0xFE25, 0xFE2B, 0xFE31, 0xFE37, 0xFE3D, 0xFE42, 0xFE48, 0xFE4D, 0xFE52,  // 80
	0xFE58, 0xFE5D, 0xFE61, 0xFE66, 0xFE6B, 0xFE6F, 0xFE74, 0xFE78, 0xFE7C, 0xFE80,  // 90
	0xFE85, 0xFE88, 0xFE8C, 0xFE90, 0xFE94, 0xFE97, 0xFE9B, 0xFE9F, 0xFEA2, 0xFEA5,  // 100
	0xFEA9, 0xFEAC, 0xFEAF, 0xFEB2, 0xFEB5, 0xFEB8, 0xFEBB, 0xFEBE, 0xFEC1, 0xFEC3,  // 110
	0xFEC6, 0xFEC9, 0xFECB, 0xFECE, 0xFED0, 0xFED3, 0xFED5, 0xFED8, 0xFEDA, 0xFEDC // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2000;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb6[]={
    0xD5D4, 0xE04E, 0xE69D, 0xEAD8, 0xEDDD, 0xF024, 0xF1E9, 0xF354, 0xF47E, 0xF575,  // 10
	0xF647, 0xF6FB, 0xF797, 0xF81F, 0xF897, 0xF902, 0xF961, 0xF9B7, 0xFA05, 0xFA4C,  // 20
	0xFA8C, 0xFAC7, 0xFAFE, 0xFB30, 0xFB5E, 0xFB89, 0xFBB1, 0xFBD7, 0xFBF9, 0xFC1A,  // 30
	0xFC39, 0xFC56, 0xFC71, 0xFC8B, 0xFCA3, 0xFCBA, 0xFCD0, 0xFCE5, 0xFCF8, 0xFD0B,  // 40
	0xFD1D, 0xFD2E, 0xFD3E, 0xFD4E, 0xFD5D, 0xFD6B, 0xFD78, 0xFD86, 0xFD92, 0xFD9E,  // 50
	0xFDAA, 0xFDB5, 0xFDC0, 0xFDCA, 0xFDD4, 0xFDDE, 0xFDE7, 0xFDF0, 0xFDF9, 0xFE01,  // 60
	0xFE09, 0xFE11, 0xFE19, 0xFE20, 0xFE27, 0xFE2E, 0xFE35, 0xFE3C, 0xFE42, 0xFE48,  // 70
	0xFE4E, 0xFE54, 0xFE5A, 0xFE5F, 0xFE65, 0xFE6A, 0xFE6F, 0xFE74, 0xFE79, 0xFE7E,  // 80
	0xFE82, 0xFE87, 0xFE8B, 0xFE90, 0xFE94, 0xFE98, 0xFE9C, 0xFEA0, 0xFEA4, 0xFEA7,  // 90
	0xFEAB, 0xFEAF, 0xFEB2, 0xFEB6, 0xFEB9, 0xFEBC, 0xFEBF, 0xFEC3, 0xFEC6, 0xFEC9,  // 100
	0xFECC, 0xFECF, 0xFED1, 0xFED4, 0xFED7, 0xFEDA, 0xFEDC, 0xFEDF, 0xFEE1, 0xFEE4,  // 110
	0xFEE6, 0xFEE9, 0xFEEB, 0xFEED, 0xFEF0, 0xFEF2, 0xFEF4, 0xFEF6, 0xFEF8, 0xFEFA // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2200;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb7[]={
    0xD5D4, 0xE116, 0xE79A, 0xEBDD, 0xEEDE, 0xF118, 0xF2D0, 0xF42E, 0xF54B, 0xF637,  // 10
	0xF6FE, 0xF7A8, 0xF83A, 0xF8BB, 0xF92B, 0xF98F, 0xF9E9, 0xFA39, 0xFA81, 0xFAC3,  // 20
	0xFAFF, 0xFB36, 0xFB69, 0xFB97, 0xFBC2, 0xFBEA, 0xFC0F, 0xFC31, 0xFC52, 0xFC70,  // 30
	0xFC8C, 0xFCA7, 0xFCC0, 0xFCD8, 0xFCEE, 0xFD03, 0xFD17, 0xFD2A, 0xFD3C, 0xFD4E,  // 40
	0xFD5E, 0xFD6E, 0xFD7D, 0xFD8B, 0xFD98, 0xFDA6, 0xFDB2, 0xFDBE, 0xFDCA, 0xFDD5,  // 50
	0xFDDF, 0xFDEA, 0xFDF3, 0xFDFD, 0xFE06, 0xFE0F, 0xFE18, 0xFE20, 0xFE28, 0xFE2F,  // 60
	0xFE37, 0xFE3E, 0xFE45, 0xFE4C, 0xFE52, 0xFE59, 0xFE5F, 0xFE65, 0xFE6B, 0xFE70,  // 70
	0xFE76, 0xFE7B, 0xFE80, 0xFE86, 0xFE8A, 0xFE8F, 0xFE94, 0xFE98, 0xFE9D, 0xFEA1,  // 80
	0xFEA5, 0xFEAA, 0xFEAE, 0xFEB2, 0xFEB5, 0xFEB9, 0xFEBD, 0xFEC0, 0xFEC4, 0xFEC7,  // 90
	0xFECB, 0xFECE, 0xFED1, 0xFED4, 0xFED7, 0xFEDA, 0xFEDD, 0xFEE0, 0xFEE3, 0xFEE6,  // 100
	0xFEE8, 0xFEEB, 0xFEEE, 0xFEF0, 0xFEF3, 0xFEF5, 0xFEF7, 0xFEFA, 0xFEFC, 0xFEFE,  // 110
	0xFF01, 0xFF03, 0xFF05, 0xFF07, 0xFF09, 0xFF0B, 0xFF0D, 0xFF0F, 0xFF11, 0xFF13 // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2400;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb8[]={
    0xD5D4, 0xE1D5, 0xE888, 0xECCD, 0xEFC4, 0xF1F1, 0xF39B, 0xF4EC, 0xF5FC, 0xF6DE,  // 10
	0xF79B, 0xF83C, 0xF8C7, 0xF940, 0xF9AA, 0xFA08, 0xFA5C, 0xFAA8, 0xFAEB, 0xFB29,  // 20
	0xFB61, 0xFB94, 0xFBC3, 0xFBEE, 0xFC16, 0xFC3C, 0xFC5E, 0xFC7E, 0xFC9C, 0xFCB8,  // 30
	0xFCD2, 0xFCEB, 0xFD02, 0xFD18, 0xFD2D, 0xFD41, 0xFD53, 0xFD65, 0xFD76, 0xFD86,  // 40
	0xFD95, 0xFDA3, 0xFDB1, 0xFDBE, 0xFDCB, 0xFDD7, 0xFDE2, 0xFDEE, 0xFDF8, 0xFE02,  // 50
	0xFE0C, 0xFE16, 0xFE1F, 0xFE28, 0xFE30, 0xFE38, 0xFE40, 0xFE48, 0xFE4F, 0xFE56,  // 60
	0xFE5D, 0xFE64, 0xFE6A, 0xFE70, 0xFE76, 0xFE7C, 0xFE82, 0xFE87, 0xFE8D, 0xFE92,  // 70
	0xFE97, 0xFE9C, 0xFEA1, 0xFEA5, 0xFEAA, 0xFEAE, 0xFEB3, 0xFEB7, 0xFEBB, 0xFEBF,  // 80
	0xFEC3, 0xFEC7, 0xFECA, 0xFECE, 0xFED1, 0xFED5, 0xFED8, 0xFEDB, 0xFEDF, 0xFEE2,  // 90
	0xFEE5, 0xFEE8, 0xFEEB, 0xFEEE, 0xFEF1, 0xFEF3, 0xFEF6, 0xFEF9, 0xFEFB, 0xFEFE,  // 100
	0xFF00, 0xFF03, 0xFF05, 0xFF07, 0xFF0A, 0xFF0C, 0xFF0E, 0xFF10, 0xFF12, 0xFF15,  // 110
	0xFF17, 0xFF19, 0xFF1B, 0xFF1D, 0xFF1E, 0xFF20, 0xFF22, 0xFF24, 0xFF26, 0xFF27 // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2600;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb9[]={
    0xD5D4, 0xE28A, 0xE962, 0xEDA8, 0xF093, 0xF2B2, 0xF44F, 0xF594, 0xF699, 0xF771,  // 10
	0xF825, 0xF8BE, 0xF941, 0xF9B4, 0xFA18, 0xFA71, 0xFAC0, 0xFB07, 0xFB46, 0xFB80,  // 20
	0xFBB5, 0xFBE5, 0xFC11, 0xFC39, 0xFC5F, 0xFC81, 0xFCA2, 0xFCC0, 0xFCDC, 0xFCF6,  // 30
	0xFD0E, 0xFD25, 0xFD3B, 0xFD50, 0xFD63, 0xFD75, 0xFD86, 0xFD97, 0xFDA6, 0xFDB5,  // 40
	0xFDC3, 0xFDD1, 0xFDDE, 0xFDEA, 0xFDF6, 0xFE01, 0xFE0C, 0xFE16, 0xFE20, 0xFE29,  // 50
	0xFE32, 0xFE3B, 0xFE44, 0xFE4C, 0xFE54, 0xFE5B, 0xFE62, 0xFE69, 0xFE70, 0xFE77,  // 60
	0xFE7D, 0xFE83, 0xFE89, 0xFE8F, 0xFE95, 0xFE9A, 0xFE9F, 0xFEA5, 0xFEAA, 0xFEAE,  // 70
	0xFEB3, 0xFEB8, 0xFEBC, 0xFEC0, 0xFEC5, 0xFEC9, 0xFECD, 0xFED1, 0xFED4, 0xFED8,  // 80
	0xFEDC, 0xFEDF, 0xFEE3, 0xFEE6, 0xFEE9, 0xFEEC, 0xFEEF, 0xFEF2, 0xFEF5, 0xFEF8,  // 90
	0xFEFB, 0xFEFE, 0xFF01, 0xFF03, 0xFF06, 0xFF09, 0xFF0B, 0xFF0D, 0xFF10, 0xFF12,  // 100
	0xFF14, 0xFF17, 0xFF19, 0xFF1B, 0xFF1D, 0xFF1F, 0xFF21, 0xFF23, 0xFF25, 0xFF27,  // 110
	0xFF29, 0xFF2B, 0xFF2D, 0xFF2F, 0xFF30, 0xFF32, 0xFF34, 0xFF36, 0xFF37, 0xFF39 // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2800;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb10[]={
    0xD5D4, 0xE337, 0xEA2B, 0xEE6E, 0xF14E, 0xF361, 0xF4F0, 0xF629, 0xF724, 0xF7F2,  // 10
	0xF89E, 0xF92F, 0xF9AC, 0xFA19, 0xFA78, 0xFACC, 0xFB17, 0xFB59, 0xFB96, 0xFBCC,  // 20
	0xFBFE, 0xFC2B, 0xFC54, 0xFC7A, 0xFC9D, 0xFCBE, 0xFCDC, 0xFCF8, 0xFD13, 0xFD2B,  // 30
	0xFD42, 0xFD58, 0xFD6C, 0xFD7F, 0xFD91, 0xFDA2, 0xFDB2, 0xFDC2, 0xFDD0, 0xFDDE,  // 40
	0xFDEB, 0xFDF8, 0xFE04, 0xFE0F, 0xFE1A, 0xFE25, 0xFE2F, 0xFE39, 0xFE42, 0xFE4B,  // 50
	0xFE53, 0xFE5B, 0xFE63, 0xFE6B, 0xFE72, 0xFE79, 0xFE80, 0xFE87, 0xFE8D, 0xFE93,  // 60
	0xFE99, 0xFE9F, 0xFEA4, 0xFEAA, 0xFEAF, 0xFEB4, 0xFEB9, 0xFEBE, 0xFEC2, 0xFEC7,  // 70
	0xFECB, 0xFECF, 0xFED4, 0xFED8, 0xFEDC, 0xFEDF, 0xFEE3, 0xFEE7, 0xFEEA, 0xFEEE,  // 80
	0xFEF1, 0xFEF4, 0xFEF7, 0xFEFA, 0xFEFE, 0xFF00, 0xFF03, 0xFF06, 0xFF09, 0xFF0C,  // 90
	0xFF0E, 0xFF11, 0xFF13, 0xFF16, 0xFF18, 0xFF1B, 0xFF1D, 0xFF1F, 0xFF22, 0xFF24,  // 100
	0xFF26, 0xFF28, 0xFF2A, 0xFF2C, 0xFF2E, 0xFF30, 0xFF32, 0xFF34, 0xFF36, 0xFF37,  // 110
	0xFF39, 0xFF3B, 0xFF3D, 0xFF3E, 0xFF40, 0xFF41, 0xFF43, 0xFF45, 0xFF46, 0xFF48 // 120
};


/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3000;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb11[]={
   0xD5D4, 0xE3E3, 0xEAEB, 0xEF26, 0xF1F8, 0xF3FD, 0xF581, 0xF6AE, 0xF79F, 0xF865,  // 10
	0xF909, 0xF994, 0xFA0B, 0xFA73, 0xFACD, 0xFB1C, 0xFB63, 0xFBA2, 0xFBDB, 0xFC0F,  // 20
	0xFC3D, 0xFC68, 0xFC8F, 0xFCB3, 0xFCD4, 0xFCF3, 0xFD0F, 0xFD2A, 0xFD43, 0xFD5A,  // 30
	0xFD6F, 0xFD84, 0xFD97, 0xFDA9, 0xFDBA, 0xFDCA, 0xFDD9, 0xFDE7, 0xFDF5, 0xFE02,  // 40
	0xFE0E, 0xFE1A, 0xFE25, 0xFE30, 0xFE3A, 0xFE44, 0xFE4E, 0xFE57, 0xFE5F, 0xFE68,  // 50
	0xFE70, 0xFE77, 0xFE7F, 0xFE86, 0xFE8D, 0xFE93, 0xFE9A, 0xFEA0, 0xFEA6, 0xFEAC,  // 60
	0xFEB1, 0xFEB7, 0xFEBC, 0xFEC1, 0xFEC6, 0xFECA, 0xFECF, 0xFED3, 0xFED8, 0xFEDC,  // 70
	0xFEE0, 0xFEE4, 0xFEE8, 0xFEEC, 0xFEEF, 0xFEF3, 0xFEF6, 0xFEFA, 0xFEFD, 0xFF00,  // 80
	0xFF03, 0xFF06, 0xFF09, 0xFF0C, 0xFF0F, 0xFF12, 0xFF15, 0xFF17, 0xFF1A, 0xFF1C,  // 90
	0xFF1F, 0xFF21, 0xFF24, 0xFF26, 0xFF28, 0xFF2B, 0xFF2D, 0xFF2F, 0xFF31, 0xFF33,  // 100
	0xFF35, 0xFF37, 0xFF39, 0xFF3B, 0xFF3D, 0xFF3E, 0xFF40, 0xFF42, 0xFF44, 0xFF45,  // 110
	0xFF47, 0xFF49, 0xFF4A, 0xFF4C, 0xFF4D, 0xFF4F, 0xFF50, 0xFF52, 0xFF53, 0xFF54 // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3200;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 1000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb12[]={
   0xD5D4, 0xE481, 0xEB9B, 0xEFCF, 0xF294, 0xF48B, 0xF604, 0xF726, 0xF80E, 0xF8CC,  // 10
	0xF969, 0xF9EE, 0xFA5F, 0xFAC2, 0xFB18, 0xFB64, 0xFBA7, 0xFBE3, 0xFC19, 0xFC4A,  // 20
	0xFC76, 0xFC9E, 0xFCC3, 0xFCE5, 0xFD05, 0xFD22, 0xFD3D, 0xFD56, 0xFD6D, 0xFD83,  // 30
	0xFD97, 0xFDAA, 0xFDBC, 0xFDCD, 0xFDDD, 0xFDEC, 0xFDFB, 0xFE08, 0xFE15, 0xFE21,  // 40
	0xFE2D, 0xFE38, 0xFE43, 0xFE4D, 0xFE57, 0xFE60, 0xFE69, 0xFE71, 0xFE79, 0xFE81,  // 50
	0xFE89, 0xFE90, 0xFE97, 0xFE9E, 0xFEA4, 0xFEAA, 0xFEB0, 0xFEB6, 0xFEBC, 0xFEC1,  // 60
	0xFEC6, 0xFECB, 0xFED0, 0xFED5, 0xFEDA, 0xFEDE, 0xFEE2, 0xFEE7, 0xFEEB, 0xFEEF,  // 70
	0xFEF2, 0xFEF6, 0xFEFA, 0xFEFD, 0xFF01, 0xFF04, 0xFF07, 0xFF0B, 0xFF0E, 0xFF11,  // 80
	0xFF14, 0xFF16, 0xFF19, 0xFF1C, 0xFF1F, 0xFF21, 0xFF24, 0xFF26, 0xFF29, 0xFF2B,  // 90
	0xFF2D, 0xFF30, 0xFF32, 0xFF34, 0xFF36, 0xFF38, 0xFF3A, 0xFF3C, 0xFF3E, 0xFF40,  // 100
	0xFF42, 0xFF44, 0xFF46, 0xFF48, 0xFF49, 0xFF4B, 0xFF4D, 0xFF4E, 0xFF50, 0xFF51,  // 110
	0xFF53, 0xFF55, 0xFF56, 0xFF57, 0xFF59, 0xFF5A, 0xFF5C, 0xFF5D, 0xFF5E, 0xFF60 // 120
};


//------------------增加12档

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1200;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb13[]={
  0xEAF2, 0xEE5E, 0xF0D9, 0xF2B7, 0xF42E, 0xF55B, 0xF652, 0xF721, 0xF7D0, 0xF866,  // 10
	0xF8E8, 0xF95B, 0xF9BF, 0xFA19, 0xFA69, 0xFAB2, 0xFAF3, 0xFB2F, 0xFB65, 0xFB97,  // 20
	0xFBC5, 0xFBEF, 0xFC16, 0xFC3A, 0xFC5C, 0xFC7C, 0xFC99, 0xFCB5, 0xFCCF, 0xFCE7,  // 30
	0xFCFE, 0xFD14, 0xFD29, 0xFD3C, 0xFD4F, 0xFD60, 0xFD71, 0xFD81, 0xFD90, 0xFD9E,  // 40
	0xFDAC, 0xFDB9, 0xFDC5, 0xFDD2, 0xFDDD, 0xFDE8, 0xFDF3, 0xFDFD, 0xFE07, 0xFE10,  // 50
	0xFE19, 0xFE22, 0xFE2B, 0xFE33, 0xFE3B, 0xFE42, 0xFE4A, 0xFE51, 0xFE58, 0xFE5F,  // 60
	0xFE65, 0xFE6B, 0xFE71, 0xFE77, 0xFE7D, 0xFE83, 0xFE88, 0xFE8D, 0xFE92, 0xFE97,  // 70
	0xFE9C, 0xFEA1, 0xFEA5, 0xFEAA, 0xFEAE, 0xFEB2, 0xFEB6, 0xFEBA, 0xFEBE, 0xFEC2,  // 80
	0xFEC6, 0xFEC9, 0xFECD, 0xFED1, 0xFED4, 0xFED7, 0xFEDA, 0xFEDE, 0xFEE1, 0xFEE4,  // 90
	0xFEE7, 0xFEEA, 0xFEEC, 0xFEEF, 0xFEF2, 0xFEF5, 0xFEF7, 0xFEFA, 0xFEFC, 0xFEFF,  // 100
	0xFF01, 0xFF04, 0xFF06, 0xFF08, 0xFF0A, 0xFF0D, 0xFF0F, 0xFF11, 0xFF13, 0xFF15,  // 110
	0xFF17, 0xFF19, 0xFF1B, 0xFF1D, 0xFF1F, 0xFF20, 0xFF22, 0xFF24, 0xFF26, 0xFF27 // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1400;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb14[]={
	0xEAF2, 0xEEDC, 0xF18E, 0xF386, 0xF505, 0xF634, 0xF728, 0xF7F1, 0xF89A, 0xF929,  // 10
	0xF9A5, 0xFA10, 0xFA6E, 0xFAC2, 0xFB0C, 0xFB4F, 0xFB8B, 0xFBC1, 0xFBF3, 0xFC20,  // 20
	0xFC4A, 0xFC70, 0xFC93, 0xFCB4, 0xFCD2, 0xFCEF, 0xFD09, 0xFD22, 0xFD39, 0xFD4F,  // 30
	0xFD63, 0xFD76, 0xFD89, 0xFD9A, 0xFDAA, 0xFDBA, 0xFDC8, 0xFDD6, 0xFDE4, 0xFDF1,  // 40
	0xFDFD, 0xFE08, 0xFE13, 0xFE1E, 0xFE28, 0xFE32, 0xFE3B, 0xFE44, 0xFE4D, 0xFE55,  // 50
	0xFE5D, 0xFE65, 0xFE6C, 0xFE73, 0xFE7A, 0xFE81, 0xFE87, 0xFE8D, 0xFE94, 0xFE99,  // 60
	0xFE9F, 0xFEA4, 0xFEAA, 0xFEAF, 0xFEB4, 0xFEB9, 0xFEBD, 0xFEC2, 0xFEC6, 0xFECB,  // 70
	0xFECF, 0xFED3, 0xFED7, 0xFEDB, 0xFEDF, 0xFEE2, 0xFEE6, 0xFEE9, 0xFEED, 0xFEF0,  // 80
	0xFEF3, 0xFEF6, 0xFEF9, 0xFEFC, 0xFEFF, 0xFF02, 0xFF05, 0xFF08, 0xFF0A, 0xFF0D,  // 90
	0xFF10, 0xFF12, 0xFF15, 0xFF17, 0xFF19, 0xFF1C, 0xFF1E, 0xFF20, 0xFF22, 0xFF24,  // 100
	0xFF27, 0xFF29, 0xFF2B, 0xFF2D, 0xFF2F, 0xFF30, 0xFF32, 0xFF34, 0xFF36, 0xFF38,  // 110
	0xFF39, 0xFF3B, 0xFF3D, 0xFF3E, 0xFF40, 0xFF42, 0xFF43, 0xFF45, 0xFF46, 0xFF48 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 8;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1600;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb15[]={
	0xEAF2, 0xEF51, 0xF231, 0xF43B, 0xF5BF, 0xF6EC, 0xF7DB, 0xF89E, 0xF940, 0xF9C9,  // 10
	0xFA3E, 0xFAA3, 0xFAFB, 0xFB49, 0xFB8E, 0xFBCC, 0xFC03, 0xFC35, 0xFC63, 0xFC8C,  // 20
	0xFCB2, 0xFCD5, 0xFCF5, 0xFD12, 0xFD2E, 0xFD48, 0xFD60, 0xFD76, 0xFD8B, 0xFD9E,  // 30
	0xFDB1, 0xFDC2, 0xFDD3, 0xFDE2, 0xFDF1, 0xFDFF, 0xFE0C, 0xFE18, 0xFE24, 0xFE30,  // 40
	0xFE3A, 0xFE45, 0xFE4F, 0xFE58, 0xFE61, 0xFE6A, 0xFE72, 0xFE7A, 0xFE82, 0xFE89,  // 50
	0xFE90, 0xFE97, 0xFE9E, 0xFEA4, 0xFEAA, 0xFEB0, 0xFEB6, 0xFEBB, 0xFEC1, 0xFEC6,  // 60
	0xFECB, 0xFED0, 0xFED4, 0xFED9, 0xFEDD, 0xFEE2, 0xFEE6, 0xFEEA, 0xFEEE, 0xFEF2,  // 70
	0xFEF5, 0xFEF9, 0xFEFC, 0xFF00, 0xFF03, 0xFF06, 0xFF0A, 0xFF0D, 0xFF10, 0xFF13,  // 80
	0xFF15, 0xFF18, 0xFF1B, 0xFF1E, 0xFF20, 0xFF23, 0xFF25, 0xFF28, 0xFF2A, 0xFF2C,  // 90
	0xFF2E, 0xFF31, 0xFF33, 0xFF35, 0xFF37, 0xFF39, 0xFF3B, 0xFF3D, 0xFF3F, 0xFF41,  // 100
	0xFF43, 0xFF44, 0xFF46, 0xFF48, 0xFF4A, 0xFF4B, 0xFF4D, 0xFF4F, 0xFF50, 0xFF52,  // 110
	0xFF53, 0xFF55, 0xFF56, 0xFF58, 0xFF59, 0xFF5A, 0xFF5C, 0xFF5D, 0xFF5E, 0xFF60 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1800;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb16[]={
	0xEAF2, 0xEFC0, 0xF2C8, 0xF4DE, 0xF663, 0xF78B, 0xF874, 0xF931, 0xF9CC, 0xFA4E,  // 10
	0xFABD, 0xFB1C, 0xFB6F, 0xFBB8, 0xFBF8, 0xFC31, 0xFC64, 0xFC93, 0xFCBD, 0xFCE3,  // 20
	0xFD06, 0xFD26, 0xFD43, 0xFD5E, 0xFD77, 0xFD8F, 0xFDA5, 0xFDB9, 0xFDCC, 0xFDDE,  // 30
	0xFDEF, 0xFDFE, 0xFE0D, 0xFE1B, 0xFE29, 0xFE35, 0xFE41, 0xFE4C, 0xFE57, 0xFE61,  // 40
	0xFE6B, 0xFE75, 0xFE7D, 0xFE86, 0xFE8E, 0xFE96, 0xFE9D, 0xFEA5, 0xFEAC, 0xFEB2,  // 50
	0xFEB9, 0xFEBF, 0xFEC5, 0xFECA, 0xFED0, 0xFED5, 0xFEDA, 0xFEDF, 0xFEE4, 0xFEE9,  // 60
	0xFEED, 0xFEF2, 0xFEF6, 0xFEFA, 0xFEFE, 0xFF02, 0xFF05, 0xFF09, 0xFF0D, 0xFF10,  // 70
	0xFF13, 0xFF17, 0xFF1A, 0xFF1D, 0xFF20, 0xFF23, 0xFF25, 0xFF28, 0xFF2B, 0xFF2D,  // 80
	0xFF30, 0xFF33, 0xFF35, 0xFF37, 0xFF3A, 0xFF3C, 0xFF3E, 0xFF40, 0xFF42, 0xFF44,  // 90
	0xFF47, 0xFF48, 0xFF4A, 0xFF4C, 0xFF4E, 0xFF50, 0xFF52, 0xFF54, 0xFF55, 0xFF57,  // 100
	0xFF59, 0xFF5A, 0xFF5C, 0xFF5D, 0xFF5F, 0xFF60, 0xFF62, 0xFF63, 0xFF65, 0xFF66,  // 110
	0xFF67, 0xFF69, 0xFF6A, 0xFF6B, 0xFF6C, 0xFF6E, 0xFF6F, 0xFF70, 0xFF71, 0xFF72 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2000;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb17[]={
	0xEAF2, 0xF02B, 0xF353, 0xF570, 0xF6F3, 0xF816, 0xF8F9, 0xF9AE, 0xFA43, 0xFABF,  // 10
	0xFB28, 0xFB82, 0xFBCF, 0xFC14, 0xFC50, 0xFC85, 0xFCB5, 0xFCE0, 0xFD07, 0xFD2A,  // 20
	0xFD4A, 0xFD68, 0xFD83, 0xFD9C, 0xFDB3, 0xFDC9, 0xFDDD, 0xFDF0, 0xFE01, 0xFE11,  // 30
	0xFE21, 0xFE2F, 0xFE3D, 0xFE4A, 0xFE56, 0xFE61, 0xFE6C, 0xFE77, 0xFE80, 0xFE8A,  // 40
	0xFE93, 0xFE9B, 0xFEA3, 0xFEAB, 0xFEB3, 0xFEBA, 0xFEC0, 0xFEC7, 0xFECD, 0xFED3,  // 50
	0xFED9, 0xFEDF, 0xFEE4, 0xFEE9, 0xFEEE, 0xFEF3, 0xFEF8, 0xFEFC, 0xFF01, 0xFF05,  // 60
	0xFF09, 0xFF0D, 0xFF11, 0xFF14, 0xFF18, 0xFF1B, 0xFF1F, 0xFF22, 0xFF25, 0xFF28,  // 70
	0xFF2B, 0xFF2E, 0xFF31, 0xFF34, 0xFF37, 0xFF39, 0xFF3C, 0xFF3E, 0xFF41, 0xFF43,  // 80
	0xFF45, 0xFF48, 0xFF4A, 0xFF4C, 0xFF4E, 0xFF50, 0xFF52, 0xFF54, 0xFF56, 0xFF58,  // 90
	0xFF5A, 0xFF5C, 0xFF5D, 0xFF5F, 0xFF61, 0xFF62, 0xFF64, 0xFF66, 0xFF67, 0xFF69,  // 100
	0xFF6A, 0xFF6C, 0xFF6D, 0xFF6E, 0xFF70, 0xFF71, 0xFF72, 0xFF74, 0xFF75, 0xFF76,  // 110
	0xFF77, 0xFF79, 0xFF7A, 0xFF7B, 0xFF7C, 0xFF7D, 0xFF7E, 0xFF7F, 0xFF80, 0xFF82 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2200;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb18[]={
	0xEAF2, 0xF08F, 0xF3D2, 0xF5F3, 0xF773, 0xF890, 0xF96C, 0xFA1B, 0xFAA9, 0xFB20,  // 10
	0xFB83, 0xFBD8, 0xFC21, 0xFC62, 0xFC9A, 0xFCCC, 0xFCF9, 0xFD21, 0xFD45, 0xFD66,  // 20
	0xFD84, 0xFD9F, 0xFDB9, 0xFDD0, 0xFDE5, 0xFDF9, 0xFE0C, 0xFE1D, 0xFE2D, 0xFE3C,  // 30
	0xFE4A, 0xFE58, 0xFE64, 0xFE70, 0xFE7B, 0xFE86, 0xFE90, 0xFE99, 0xFEA2, 0xFEAB,  // 40
	0xFEB3, 0xFEBB, 0xFEC3, 0xFECA, 0xFED0, 0xFED7, 0xFEDD, 0xFEE3, 0xFEE9, 0xFEEF,  // 50
	0xFEF4, 0xFEF9, 0xFEFE, 0xFF03, 0xFF07, 0xFF0C, 0xFF10, 0xFF14, 0xFF18, 0xFF1C,  // 60
	0xFF20, 0xFF23, 0xFF27, 0xFF2A, 0xFF2D, 0xFF31, 0xFF34, 0xFF37, 0xFF3A, 0xFF3C,  // 70
	0xFF3F, 0xFF42, 0xFF44, 0xFF47, 0xFF49, 0xFF4C, 0xFF4E, 0xFF50, 0xFF53, 0xFF55,  // 80
	0xFF57, 0xFF59, 0xFF5B, 0xFF5D, 0xFF5F, 0xFF61, 0xFF63, 0xFF64, 0xFF66, 0xFF68,  // 90
	0xFF6A, 0xFF6B, 0xFF6D, 0xFF6E, 0xFF70, 0xFF71, 0xFF73, 0xFF74, 0xFF76, 0xFF77,  // 100
	0xFF78, 0xFF7A, 0xFF7B, 0xFF7C, 0xFF7E, 0xFF7F, 0xFF80, 0xFF81, 0xFF82, 0xFF83,  // 110
	0xFF85, 0xFF86, 0xFF87, 0xFF88, 0xFF89, 0xFF8A, 0xFF8B, 0xFF8C, 0xFF8D, 0xFF8E // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2400;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb19[]={
	0xEAF2, 0xF0EF, 0xF447, 0xF66B, 0xF7E6, 0xF8FD, 0xF9D2, 0xFA7A, 0xFB03, 0xFB73,  // 10
	0xFBD2, 0xFC22, 0xFC68, 0xFCA4, 0xFCD9, 0xFD08, 0xFD32, 0xFD58, 0xFD7A, 0xFD99,  // 20
	0xFDB5, 0xFDCE, 0xFDE6, 0xFDFB, 0xFE0F, 0xFE22, 0xFE33, 0xFE43, 0xFE52, 0xFE60,  // 30
	0xFE6D, 0xFE7A, 0xFE85, 0xFE90, 0xFE9B, 0xFEA5, 0xFEAE, 0xFEB7, 0xFEBF, 0xFEC7,  // 40
	0xFECF, 0xFED6, 0xFEDD, 0xFEE3, 0xFEEA, 0xFEF0, 0xFEF5, 0xFEFB, 0xFF00, 0xFF05,  // 50
	0xFF0A, 0xFF0F, 0xFF14, 0xFF18, 0xFF1C, 0xFF20, 0xFF24, 0xFF28, 0xFF2C, 0xFF2F,  // 60
	0xFF33, 0xFF36, 0xFF39, 0xFF3C, 0xFF3F, 0xFF42, 0xFF45, 0xFF48, 0xFF4B, 0xFF4D,  // 70
	0xFF50, 0xFF52, 0xFF55, 0xFF57, 0xFF59, 0xFF5B, 0xFF5E, 0xFF60, 0xFF62, 0xFF64,  // 80
	0xFF66, 0xFF68, 0xFF69, 0xFF6B, 0xFF6D, 0xFF6F, 0xFF70, 0xFF72, 0xFF74, 0xFF75,  // 90
	0xFF77, 0xFF78, 0xFF7A, 0xFF7B, 0xFF7D, 0xFF7E, 0xFF7F, 0xFF81, 0xFF82, 0xFF83,  // 100
	0xFF84, 0xFF86, 0xFF87, 0xFF88, 0xFF89, 0xFF8A, 0xFF8B, 0xFF8C, 0xFF8D, 0xFF8F,  // 110
	0xFF90, 0xFF91, 0xFF92, 0xFF93, 0xFF93, 0xFF94, 0xFF95, 0xFF96, 0xFF97, 0xFF98 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2600;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb20[]={
	0xEAF2, 0xF14B, 0xF4B5, 0xF6D8, 0xF84E, 0xF95D, 0xFA2C, 0xFACE, 0xFB51, 0xFBBD,  // 10
	0xFC17, 0xFC63, 0xFCA5, 0xFCDE, 0xFD10, 0xFD3D, 0xFD64, 0xFD88, 0xFDA7, 0xFDC4,  // 20
	0xFDDF, 0xFDF7, 0xFE0D, 0xFE21, 0xFE34, 0xFE45, 0xFE55, 0xFE64, 0xFE72, 0xFE7F,  // 30
	0xFE8B, 0xFE97, 0xFEA2, 0xFEAC, 0xFEB6, 0xFEBF, 0xFEC7, 0xFED0, 0xFED7, 0xFEDF,  // 40
	0xFEE6, 0xFEED, 0xFEF3, 0xFEF9, 0xFEFF, 0xFF05, 0xFF0A, 0xFF0F, 0xFF14, 0xFF19,  // 50
	0xFF1D, 0xFF22, 0xFF26, 0xFF2A, 0xFF2E, 0xFF32, 0xFF35, 0xFF39, 0xFF3C, 0xFF40,  // 60
	0xFF43, 0xFF46, 0xFF49, 0xFF4C, 0xFF4F, 0xFF51, 0xFF54, 0xFF57, 0xFF59, 0xFF5B,  // 70
	0xFF5E, 0xFF60, 0xFF62, 0xFF64, 0xFF67, 0xFF69, 0xFF6B, 0xFF6D, 0xFF6E, 0xFF70,  // 80
	0xFF72, 0xFF74, 0xFF76, 0xFF77, 0xFF79, 0xFF7A, 0xFF7C, 0xFF7D, 0xFF7F, 0xFF80,  // 90
	0xFF82, 0xFF83, 0xFF85, 0xFF86, 0xFF87, 0xFF89, 0xFF8A, 0xFF8B, 0xFF8C, 0xFF8D,  // 100
	0xFF8E, 0xFF90, 0xFF91, 0xFF92, 0xFF93, 0xFF94, 0xFF95, 0xFF96, 0xFF97, 0xFF98,  // 110
	0xFF99, 0xFF9A, 0xFF9B, 0xFF9C, 0xFF9C, 0xFF9D, 0xFF9E, 0xFF9F, 0xFFA0, 0xFFA1 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2800;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb21[]={
	0xEAF2, 0xF1A1, 0xF51B, 0xF73C, 0xF8AB, 0xF9B4, 0xFA7C, 0xFB19, 0xFB96, 0xFBFD,  // 10
	0xFC53, 0xFC9C, 0xFCDB, 0xFD11, 0xFD40, 0xFD6A, 0xFD90, 0xFDB1, 0xFDCF, 0xFDEA,  // 20
	0xFE03, 0xFE1A, 0xFE2E, 0xFE41, 0xFE53, 0xFE63, 0xFE72, 0xFE80, 0xFE8E, 0xFE9A,  // 30
	0xFEA5, 0xFEB0, 0xFEBA, 0xFEC4, 0xFECD, 0xFED5, 0xFEDD, 0xFEE5, 0xFEEC, 0xFEF3,  // 40
	0xFEFA, 0xFF00, 0xFF06, 0xFF0C, 0xFF11, 0xFF17, 0xFF1C, 0xFF21, 0xFF25, 0xFF2A,  // 50
	0xFF2E, 0xFF32, 0xFF36, 0xFF3A, 0xFF3D, 0xFF41, 0xFF44, 0xFF48, 0xFF4B, 0xFF4E,  // 60
	0xFF51, 0xFF54, 0xFF56, 0xFF59, 0xFF5C, 0xFF5E, 0xFF61, 0xFF63, 0xFF65, 0xFF68,  // 70
	0xFF6A, 0xFF6C, 0xFF6E, 0xFF70, 0xFF72, 0xFF74, 0xFF76, 0xFF78, 0xFF79, 0xFF7B,  // 80
	0xFF7D, 0xFF7E, 0xFF80, 0xFF81, 0xFF83, 0xFF84, 0xFF86, 0xFF87, 0xFF89, 0xFF8A,  // 90
	0xFF8B, 0xFF8D, 0xFF8E, 0xFF8F, 0xFF90, 0xFF92, 0xFF93, 0xFF94, 0xFF95, 0xFF96,  // 100
	0xFF97, 0xFF98, 0xFF99, 0xFF9A, 0xFF9B, 0xFF9C, 0xFF9D, 0xFF9E, 0xFF9F, 0xFFA0,  // 110
	0xFFA1, 0xFFA2, 0xFFA3, 0xFFA3, 0xFFA4, 0xFFA5, 0xFFA6, 0xFFA7, 0xFFA7, 0xFFA8 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3000;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb22[]={
	0xEAF2, 0xF1F4, 0xF57A, 0xF797, 0xF900, 0xFA03, 0xFAC5, 0xFB5B, 0xFBD4, 0xFC37,  // 10
	0xFC89, 0xFCCE, 0xFD0A, 0xFD3D, 0xFD6B, 0xFD92, 0xFDB6, 0xFDD5, 0xFDF2, 0xFE0C,  // 20
	0xFE23, 0xFE38, 0xFE4C, 0xFE5E, 0xFE6E, 0xFE7E, 0xFE8C, 0xFE99, 0xFEA6, 0xFEB1,  // 30
	0xFEBC, 0xFEC6, 0xFED0, 0xFED9, 0xFEE1, 0xFEE9, 0xFEF1, 0xFEF8, 0xFEFF, 0xFF05,  // 40
	0xFF0B, 0xFF11, 0xFF17, 0xFF1C, 0xFF21, 0xFF26, 0xFF2B, 0xFF30, 0xFF34, 0xFF38,  // 50
	0xFF3C, 0xFF40, 0xFF44, 0xFF47, 0xFF4B, 0xFF4E, 0xFF51, 0xFF54, 0xFF57, 0xFF5A,  // 60
	0xFF5D, 0xFF60, 0xFF62, 0xFF65, 0xFF67, 0xFF69, 0xFF6C, 0xFF6E, 0xFF70, 0xFF72,  // 70
	0xFF74, 0xFF76, 0xFF78, 0xFF7A, 0xFF7C, 0xFF7E, 0xFF7F, 0xFF81, 0xFF83, 0xFF84,  // 80
	0xFF86, 0xFF87, 0xFF89, 0xFF8A, 0xFF8C, 0xFF8D, 0xFF8F, 0xFF90, 0xFF91, 0xFF92,  // 90
	0xFF94, 0xFF95, 0xFF96, 0xFF97, 0xFF98, 0xFF99, 0xFF9B, 0xFF9C, 0xFF9D, 0xFF9E,  // 100
	0xFF9F, 0xFFA0, 0xFFA1, 0xFFA2, 0xFFA3, 0xFFA3, 0xFFA4, 0xFFA5, 0xFFA6, 0xFFA7,  // 110
	0xFFA8, 0xFFA9, 0xFFA9, 0xFFAA, 0xFFAB, 0xFFAC, 0xFFAC, 0xFFAD, 0xFFAE, 0xFFAE // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3200;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb23[]={
	0xEAF2, 0xF245, 0xF5D2, 0xF7EB, 0xF94E, 0xFA4A, 0xFB06, 0xFB97, 0xFC0B, 0xFC6A,  // 10
	0xFCB9, 0xFCFB, 0xFD34, 0xFD65, 0xFD90, 0xFDB6, 0xFDD8, 0xFDF6, 0xFE11, 0xFE29,  // 20
	0xFE3F, 0xFE53, 0xFE66, 0xFE77, 0xFE87, 0xFE95, 0xFEA3, 0xFEAF, 0xFEBB, 0xFEC6,  // 30
	0xFED0, 0xFED9, 0xFEE2, 0xFEEB, 0xFEF3, 0xFEFA, 0xFF02, 0xFF08, 0xFF0F, 0xFF15,  // 40
	0xFF1B, 0xFF20, 0xFF26, 0xFF2B, 0xFF30, 0xFF34, 0xFF39, 0xFF3D, 0xFF41, 0xFF45,  // 50
	0xFF49, 0xFF4C, 0xFF50, 0xFF53, 0xFF56, 0xFF59, 0xFF5C, 0xFF5F, 0xFF62, 0xFF65,  // 60
	0xFF67, 0xFF6A, 0xFF6C, 0xFF6F, 0xFF71, 0xFF73, 0xFF75, 0xFF78, 0xFF7A, 0xFF7C,  // 70
	0xFF7D, 0xFF7F, 0xFF81, 0xFF83, 0xFF85, 0xFF86, 0xFF88, 0xFF8A, 0xFF8B, 0xFF8D,  // 80
	0xFF8E, 0xFF8F, 0xFF91, 0xFF92, 0xFF94, 0xFF95, 0xFF96, 0xFF97, 0xFF99, 0xFF9A,  // 90
	0xFF9B, 0xFF9C, 0xFF9D, 0xFF9E, 0xFF9F, 0xFFA0, 0xFFA1, 0xFFA2, 0xFFA3, 0xFFA4,  // 100
	0xFFA5, 0xFFA6, 0xFFA7, 0xFFA8, 0xFFA9, 0xFFAA, 0xFFAB, 0xFFAB, 0xFFAC, 0xFFAD,  // 110
	0xFFAE, 0xFFAF, 0xFFAF, 0xFFB0, 0xFFB1, 0xFFB1, 0xFFB2, 0xFFB3, 0xFFB3, 0xFFB4 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3400;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb24[]={
	0xEAF2, 0xF290, 0xF625, 0xF83A, 0xF996, 0xFA8B, 0xFB41, 0xFBCE, 0xFC3D, 0xFC98,  // 10
	0xFCE4, 0xFD23, 0xFD5A, 0xFD89, 0xFDB2, 0xFDD6, 0xFDF6, 0xFE12, 0xFE2C, 0xFE43,  // 20
	0xFE58, 0xFE6B, 0xFE7D, 0xFE8D, 0xFE9C, 0xFEAA, 0xFEB7, 0xFEC2, 0xFECD, 0xFED8,  // 30
	0xFEE1, 0xFEEB, 0xFEF3, 0xFEFB, 0xFF03, 0xFF0A, 0xFF11, 0xFF17, 0xFF1D, 0xFF23,  // 40
	0xFF28, 0xFF2E, 0xFF33, 0xFF37, 0xFF3C, 0xFF40, 0xFF45, 0xFF49, 0xFF4C, 0xFF50,  // 50
	0xFF54, 0xFF57, 0xFF5A, 0xFF5E, 0xFF61, 0xFF64, 0xFF66, 0xFF69, 0xFF6C, 0xFF6E,  // 60
	0xFF71, 0xFF73, 0xFF75, 0xFF78, 0xFF7A, 0xFF7C, 0xFF7E, 0xFF80, 0xFF82, 0xFF84,  // 70
	0xFF86, 0xFF87, 0xFF89, 0xFF8B, 0xFF8C, 0xFF8E, 0xFF8F, 0xFF91, 0xFF92, 0xFF94,  // 80
	0xFF95, 0xFF97, 0xFF98, 0xFF99, 0xFF9A, 0xFF9C, 0xFF9D, 0xFF9E, 0xFF9F, 0xFFA0,  // 90
	0xFFA1, 0xFFA2, 0xFFA4, 0xFFA5, 0xFFA6, 0xFFA7, 0xFFA7, 0xFFA8, 0xFFA9, 0xFFAA,  // 100
	0xFFAB, 0xFFAC, 0xFFAD, 0xFFAE, 0xFFAE, 0xFFAF, 0xFFB0, 0xFFB1, 0xFFB2, 0xFFB2,  // 110
	0xFFB3, 0xFFB4, 0xFFB4, 0xFFB5, 0xFFB6, 0xFFB7, 0xFFB7, 0xFFB8, 0xFFB8, 0xFFB9 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 2;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3600;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb25[]={
	0xEAF2, 0xF2D9, 0xF673, 0xF882, 0xF9D7, 0xFAC7, 0xFB77, 0xFBFF, 0xFC6B, 0xFCC2,  // 10
	0xFD0B, 0xFD48, 0xFD7C, 0xFDA9, 0xFDD0, 0xFDF2, 0xFE11, 0xFE2C, 0xFE45, 0xFE5B,  // 20
	0xFE6F, 0xFE81, 0xFE92, 0xFEA1, 0xFEAF, 0xFEBC, 0xFEC8, 0xFED4, 0xFEDE, 0xFEE8,  // 30
	0xFEF1, 0xFEFA, 0xFF02, 0xFF0A, 0xFF11, 0xFF18, 0xFF1E, 0xFF24, 0xFF2A, 0xFF2F,  // 40
	0xFF35, 0xFF3A, 0xFF3E, 0xFF43, 0xFF47, 0xFF4B, 0xFF4F, 0xFF53, 0xFF57, 0xFF5A,  // 50
	0xFF5E, 0xFF61, 0xFF64, 0xFF67, 0xFF6A, 0xFF6D, 0xFF6F, 0xFF72, 0xFF74, 0xFF77,  // 60
	0xFF79, 0xFF7B, 0xFF7E, 0xFF80, 0xFF82, 0xFF84, 0xFF86, 0xFF87, 0xFF89, 0xFF8B,  // 70
	0xFF8D, 0xFF8E, 0xFF90, 0xFF92, 0xFF93, 0xFF95, 0xFF96, 0xFF98, 0xFF99, 0xFF9A,  // 80
	0xFF9C, 0xFF9D, 0xFF9E, 0xFF9F, 0xFFA1, 0xFFA2, 0xFFA3, 0xFFA4, 0xFFA5, 0xFFA6,  // 90
	0xFFA7, 0xFFA8, 0xFFA9, 0xFFAA, 0xFFAB, 0xFFAC, 0xFFAD, 0xFFAE, 0xFFAF, 0xFFAF,  // 100
	0xFFB0, 0xFFB1, 0xFFB2, 0xFFB3, 0xFFB3, 0xFFB4, 0xFFB5, 0xFFB6, 0xFFB6, 0xFFB7,  // 110
	0xFFB8, 0xFFB8, 0xFFB9, 0xFFBA, 0xFFBA, 0xFFBB, 0xFFBC, 0xFFBC, 0xFFBD, 0xFFBD // 120
	
};


/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 4;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3800;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb26[]={
	0xEAF2, 0xF31E, 0xF6BC, 0xF8C5, 0xFA14, 0xFAFD, 0xFBA9, 0xFC2C, 0xFC94, 0xFCE8,  // 10
	0xFD2E, 0xFD69, 0xFD9B, 0xFDC6, 0xFDEB, 0xFE0C, 0xFE29, 0xFE43, 0xFE5B, 0xFE70,  // 20
	0xFE83, 0xFE95, 0xFEA4, 0xFEB3, 0xFEC1, 0xFECD, 0xFED9, 0xFEE3, 0xFEED, 0xFEF7,  // 30
	0xFEFF, 0xFF08, 0xFF0F, 0xFF17, 0xFF1D, 0xFF24, 0xFF2A, 0xFF30, 0xFF35, 0xFF3A,  // 40
	0xFF3F, 0xFF44, 0xFF49, 0xFF4D, 0xFF51, 0xFF55, 0xFF59, 0xFF5C, 0xFF60, 0xFF63,  // 50
	0xFF66, 0xFF69, 0xFF6C, 0xFF6F, 0xFF72, 0xFF75, 0xFF77, 0xFF7A, 0xFF7C, 0xFF7E,  // 60
	0xFF81, 0xFF83, 0xFF85, 0xFF87, 0xFF89, 0xFF8B, 0xFF8C, 0xFF8E, 0xFF90, 0xFF92,  // 70
	0xFF93, 0xFF95, 0xFF96, 0xFF98, 0xFF99, 0xFF9B, 0xFF9C, 0xFF9D, 0xFF9F, 0xFFA0,  // 80
	0xFFA1, 0xFFA2, 0xFFA4, 0xFFA5, 0xFFA6, 0xFFA7, 0xFFA8, 0xFFA9, 0xFFAA, 0xFFAB,  // 90
	0xFFAC, 0xFFAD, 0xFFAE, 0xFFAF, 0xFFB0, 0xFFB1, 0xFFB2, 0xFFB2, 0xFFB3, 0xFFB4,  // 100
	0xFFB5, 0xFFB6, 0xFFB6, 0xFFB7, 0xFFB8, 0xFFB9, 0xFFB9, 0xFFBA, 0xFFBB, 0xFFBB,  // 110
	0xFFBC, 0xFFBD, 0xFFBD, 0xFFBE, 0xFFBF, 0xFFBF, 0xFFC0, 0xFFC0, 0xFFC1, 0xFFC1 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 72.000000;
预分频率     = 4;
起步速度     = 50;
极限终点     = 119;
极限转速     = 4000;
曲率调节参数 = 100;
前端加速曲率调节 = 70;
中速辅助调节 = 30;
周脉冲数     = 2000;
中断响应编程补偿 = 8;
S梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb27[]={
	0xEAF2, 0xF362, 0xF701, 0xF904, 0xFA4C, 0xFB2F, 0xFBD6, 0xFC55, 0xFCBA, 0xFD0B,  // 10
	0xFD4E, 0xFD87, 0xFDB7, 0xFDE0, 0xFE04, 0xFE24, 0xFE40, 0xFE59, 0xFE6F, 0xFE83,  // 20
	0xFE95, 0xFEA6, 0xFEB5, 0xFEC3, 0xFED0, 0xFEDC, 0xFEE7, 0xFEF1, 0xFEFB, 0xFF04,  // 30
	0xFF0C, 0xFF14, 0xFF1B, 0xFF22, 0xFF29, 0xFF2F, 0xFF35, 0xFF3A, 0xFF40, 0xFF45,  // 40
	0xFF49, 0xFF4E, 0xFF52, 0xFF56, 0xFF5A, 0xFF5E, 0xFF61, 0xFF65, 0xFF68, 0xFF6B,  // 50
	0xFF6E, 0xFF71, 0xFF74, 0xFF77, 0xFF79, 0xFF7C, 0xFF7E, 0xFF81, 0xFF83, 0xFF85,  // 60
	0xFF87, 0xFF89, 0xFF8B, 0xFF8D, 0xFF8F, 0xFF91, 0xFF93, 0xFF94, 0xFF96, 0xFF98,  // 70
	0xFF99, 0xFF9B, 0xFF9C, 0xFF9D, 0xFF9F, 0xFFA0, 0xFFA1, 0xFFA3, 0xFFA4, 0xFFA5,  // 80
	0xFFA6, 0xFFA8, 0xFFA9, 0xFFAA, 0xFFAB, 0xFFAC, 0xFFAD, 0xFFAE, 0xFFAF, 0xFFB0,  // 90
	0xFFB1, 0xFFB2, 0xFFB3, 0xFFB3, 0xFFB4, 0xFFB5, 0xFFB6, 0xFFB7, 0xFFB8, 0xFFB8,  // 100
	0xFFB9, 0xFFBA, 0xFFBB, 0xFFBB, 0xFFBC, 0xFFBD, 0xFFBD, 0xFFBE, 0xFFBF, 0xFFBF,  // 110
	0xFFC0, 0xFFC0, 0xFFC1, 0xFFC2, 0xFFC2, 0xFFC3, 0xFFC3, 0xFFC4, 0xFFC4, 0xFFC5 // 120
	
};

/////////////////////////////////////////////////////////////////////---------------------------------------------------
// 晶振频率=96MHz; 预分频率=4
// 参数设定值: V0 = 20; 折点1= 100; 折点2 = 1750 极限转速 = 2000 rpm
//         Point0= 0;第一折点= 12;第二折点= 100; 终点步数= 120
// 电机转动一周对应脉冲数=1200; 编程响应(CTn rewrite)补偿步数 = 8
/////////////////////////////////////////////////////////////////////////
unsigned int const waitTb88[]={
    0x5040,0x7368,0x8AD8,0x9B95,0xA824,0xB1E8,0xB9B8,0xC01C,0xC570,0xC9F1, // 10
    0xCDCE,0xD635,0xDC34,0xE0B1,0xE42F,0xE6F9,0xE942,0xEB28,0xECC4,0xEE25, // 20
    0xEF57,0xF062,0xF14E,0xF220,0xF2DB,0xF384,0xF41D,0xF4A7,0xF526,0xF59A, // 30
    0xF605,0xF668,0xF6C3,0xF718,0xF767,0xF7B1,0xF7F6,0xF836,0xF873,0xF8AC, // 40
    0xF8E2,0xF915,0xF945,0xF972,0xF99E,0xF9C7,0xF9EE,0xFA13,0xFA36,0xFA58, // 50
    0xFA79,0xFA98,0xFAB5,0xFAD2,0xFAED,0xFB07,0xFB20,0xFB38,0xFB4F,0xFB66, // 60
    0xFB7B,0xFB90,0xFBA4,0xFBB8,0xFBCA,0xFBDC,0xFBEE,0xFBFF,0xFC0F,0xFC1F, // 70
    0xFC2F,0xFC3D,0xFC4C,0xFC5A,0xFC68,0xFC75,0xFC82,0xFC8E,0xFC9B,0xFCA6, // 80
    0xFCB2,0xFCBD,0xFCC8,0xFCD3,0xFCDD,0xFCE7,0xFCF1,0xFCFB,0xFD04,0xFD0D, // 90
    0xFD16,0xFD1F,0xFD28,0xFD30,0xFD38,0xFD40,0xFD48,0xFD50,0xFD57,0xFD5C, // 100
    0xFD60,0xFD65,0xFD69,0xFD6E,0xFD72,0xFD77,0xFD7B,0xFD7F,0xFD83,0xFD87, // 110
    0xFD8B,0xFD8F,0xFD93,0xFD97,0xFD9B,0xFD9F,0xFDA3,0xFDA6,0xFDAA,0xFDAE
};
//start  run


void Timer0IntrHandler(void)   //50US 定时中断
{
  unsigned long int i;
  Int32U temp;

   
  ////*******************************************
   switch(MotorType)
	{
	case MOTOR_FREQ_5_SPD_RST:
	case MOTOR_FREQ_3_SPD:
	case MOTOR_FREQ_3_SPD_RST:
				if(OIN6_PIN)   //如果第一路光藕输入为高?
			{
					xa1=1;
				}
				
				 if(OIN7_PIN)   //如果第一路光藕输入为高?
			{
					xb1=1;
				}
				   
				if(!OIN6_PIN)   //如果第一路光藕输入为高?
			{
					xa1=0;
				}
				
				 if(!OIN7_PIN)   //如果第一路光藕输入为高?
			{
					xb1=0;
				}    
			   
				   if(OIN8_PIN)   //如果第一路光藕输入为高?
			{
					xz=1;
				}
					
				  if(!OIN8_PIN)   //如果第一路光藕输入为高?
			{   
					xz=0;
				}
				
				if(OIN1_PIN)   //如果第一路光藕输入为高?
			{   
				   senor=1;
				   xsenor1=1;
				}
				
				if(!OIN1_PIN)   //如果第一路光藕输入为高?
			{
				   senor=0;
					xsenor1=1;
				   if(flagyunxing==1)
				   {
					  flagsenor=1;
				   }   
				}
				
					
			  
				
		   if(xa==0&&xb==0)  
		  { 
			if(xa1==1&&xb1==0)
			  { 
				 qianjin=0;
				  houtui=1;
				 muqiancn=muqiancn+maichongdangliang;  
				// CurrentSize=muqiancn/1000;
				// xxmuqiancn=xxmuqiancn+maichongdangliang;
			  }
		  }
		  
		   if(xa==1&&xb==0)  
		  { 
			if(xa1==1&&xb1==1)
			  {  
				 qianjin=0;
				 houtui=1;
			   muqiancn=muqiancn+maichongdangliang;
			//   CurrentSize=muqiancn/1000;
			 // xxmuqiancn=xxmuqiancn+maichongdangliang;
			   }
		 }
		 
		  if(xa==1&&xb==1)  
		  { 
			if(xa1==0&&xb1==1)
			  {  
				  qianjin=0;
				  houtui=1;
				  muqiancn=muqiancn+maichongdangliang; 
			//	  CurrentSize=muqiancn/1000;
				//  xxmuqiancn=xxmuqiancn+maichongdangliang;
			   }
		  }
		  
		   if(xa==0&&xb==1)
			{
			  if(xa1==0&&xb1==0)
				{ 
				  qianjin=0;
				  houtui=1;
				  muqiancn=muqiancn+maichongdangliang; 
			//	  CurrentSize=muqiancn/1000;
			//	  xxmuqiancn=xxmuqiancn+maichongdangliang;
				}
			}
		  
		  
		   if(xa==0&&xb==0)
			 {
			  if(xa1==0&&xb1==1)
				{ 
				qianjin=1;
				  houtui=0; 
				 muqiancn=muqiancn-maichongdangliang;
			//	 CurrentSize=muqiancn/1000;
				// xxmuqiancn=xxmuqiancn-maichongdangliang;
				 Zpulse_cou++;
				}
			 }
			 
		  
			if(xa==0&&xb==1)
			 {
			 if(xa1==1&&xb1==1)
			   {  
				qianjin=1;
				  houtui=0;
				  muqiancn=muqiancn-maichongdangliang;  
			//	  CurrentSize=muqiancn/1000;
			//	  xxmuqiancn=xxmuqiancn-maichongdangliang;
				  Zpulse_cou++;
				}
			 }    
				
			if(xa==1&&xb==1)
			 {
			  if(xa1==1&&xb1==0)
				{ 
				  qianjin=1;
				  houtui=0;
				  muqiancn=muqiancn-maichongdangliang;
			//	  CurrentSize=muqiancn/1000;
				//  xxmuqiancn=xxmuqiancn-maichongdangliang;
				  Zpulse_cou++;
				}
			  }
			 
			  
			  if(xa==1&&xb==0)
		  {
			if(xa1==0&&xb1==0)
			  { 
			   qianjin=1;
			   houtui=0;
			   muqiancn=muqiancn-maichongdangliang; 
			 //  CurrentSize=muqiancn/1000;
			//   xxmuqiancn=xxmuqiancn-maichongdangliang;
			   Zpulse_cou++;
			  }
		  }  
			  
		   xa=xa1;
		   xb=xb1;    
		   
		 //---------------------------------------------------------------
		 CurrentSize=muqiancn/1000;
		if(Run_flag==1)
			{
			if(ToTargetStop_flag==0)
				{
				if(Backward_flag==1)     //后退
					{
					if(BackStop_flag==0)
						{
						if(TargetSize<CurrentSize)
							{
							temp=CurrentSize-TargetSize;
							if(temp>100) //后退停止
								{
								//SetMotorSpeed(5); 
								MoveStop();
								if(ForceStop_flag==0)
									{
									BackStop_flag=1;
									stop_time=0;
									}
								else  //手动 停止
									{
									Backward_flag=0;
									Run_flag=0;
									ForceStop_flag=0;
									}
								}
							}
						}
					}
				else if(Forward_flag==1)  //前进
					{
					//if(CurrentSize<TargetSize+MARGIN_SIZE)
						///{
						//temp=CurrentSize-TargetSize;
						//}
					//else	
						//{
						//temp=TargetSize-CurrentSize;
					//	}
					if(CurrentSize<TargetSize+Aheader)    //停止运行
						{
						MoveStop();
						Forward_flag=0;
						Run_flag=0;
						ForceStop_flag=0;
						//RunStop_flag=1;
						stop_time=0;
						   
						ToTargetStop_flag=1;
						SelfLockEn_flag=1;
						StopDelay_flag=1;
						StopDelayCou=0;
						FreqMotorStop_flag=0;
					    StopMotorExec();
						}
					}
				}
				
			}
		
		if(SelfLockEn_flag==1)  
					{
					if(Wheel_limit==1)
						{
						SelfLockEn_flag=0;//自锁 取消
						ToTargetStop_flag=0;
						TargetSize=0;
						BeforeKnife_offset_in=0;
						InTargetPosit_flag=0;	//清目标 标志
						
						MoveStop();
						ForceStop_flag=0;
						BackStop_flag=0;
						Backward_flag=0;
						Forward_flag=0;
						Run_flag=0;
						AutoPushRun_flag=0;
						}
					}
					
					
		if(ToTargetStop_flag==1)	//到目标停止后
			{
			if(SelfLockEn_flag==1)
				{
				if(StopDelay_flag==1)
					{
					StopDelayCou++;
					if(StopDelayCou>4000)//0.2s
						{
						StopDelay_flag=0;
						}
					}
				else
					{
					if(TargetSize<CurrentSize)
						{
						temp=CurrentSize-TargetSize;
						if(temp>15)  //继续  低速  前进
							{
							//if(Forward_flag==0)
								//{
								MoveForward();//前进
								//Forward_flag=1;
								//}
							//if(MoveSpeed!=4)  //低速 
								//{
								MoveSpeed=4;
								SetMotorSpeed(MoveSpeed);
								//}
							FreqMotorStop_flag=0;
							InTargetPosit_flag=0;	//清目标 标志
							}
						else
							{
							if(FreqMotorStop_flag==0)
								{
								MoveStop();             //完全停止
								Forward_flag=0;
								ForceStop_flag=0;
								RunStop_flag=1;
								stop_time=0;
								FreqMotorStop_flag=1;
								if(MotorType==MOTOR_FREQ_3_SPD)
									SelfLockEn_flag=0;
								}
							
							//ToTargetStop_flag=0;
							}
						}
					else	
						{
						temp=TargetSize-CurrentSize;
						if(temp>15)  //继续  低速  后退
							{
							//if(Backward_flag==0)
							//	{
								MoveBack();  //后退
							//	Backward_flag=1;
							//	}
							//if(MoveSpeed!=4)  //低速 
							//	{
								MoveSpeed=4;
								SetMotorSpeed(MoveSpeed);
							//	}
							FreqMotorStop_flag=0;
							InTargetPosit_flag=0;	//清目标 标志
							}
						else
							{
							if(FreqMotorStop_flag==0)
								{
								MoveStop();
								Backward_flag=0;
								ForceStop_flag=0;
								RunStop_flag=1;
								stop_time=0;
								FreqMotorStop_flag=1;
								if(MotorType==MOTOR_FREQ_3_SPD)
									SelfLockEn_flag=0;
								}
						   
							//ToTargetStop_flag=0;
							}
						}
					}
				}
			else
				{
				if(InTargetPosit_flag==1)
					{
					if(CurrentSize>TargetSize)
						{
						temp=CurrentSize-TargetSize;
						}
					else
						{
						temp=TargetSize-CurrentSize;
						}
					if(temp>=MARGIN_SIZE)  //超出误差值
						{
						InTargetPosit_flag=0;
						}
					}
				
				}
			
			}
			
			
			break;
	case MOTOR_DC_SERVO:
		
			break;
	case MOTOR_AC_SERVO:
			if(OIN1_PIN)   //如果第一路光藕输入为高?
				{  
				senor=1;
				}
			 
			if(!OIN1_PIN)   //如果第一路光藕输入为高?
				{
				senor=0;
				}
		if((ElectricWheelOn_flag==1)&&(Run_flag==0))
			{
			if((AllPressUp_flag==1)&&(AllKnifeUp_flag==1))
				{
				 if(OIN6_PIN)   //如果第一路光藕输入为高?
					{
					xa1=1;
					}
				
				 if(OIN7_PIN)   //如果第一路光藕输入为高?
					{  
					xb1=1;
					}
					
				 if(!OIN6_PIN)   //如果第一路光藕输入为高?
					{
					xa1=0;
					}
				
				 if(!OIN7_PIN)   //如果第一路光藕输入为高?
					{
					xb1=0;
					}    
				   
				//if(flagshoulun==0)
				if(xa==0&&xb==0)  
					{ 
					if(xa1==1&&xb1==0)
						{ 
						InTargetPosit_flag=0;
					   //   BellOUT_ON;
						M_DOUT_OFF ;
					   //    M_POUT_ON ;
						//   i=100;
						// while(i--);
						//  M_POUT_OFF ;
						//  houtuicn=houtuicn+1;      
						  
						  i=100;
						  while(i--);
						  
						  M_POUT_ON ;
						  i=100;
						  while(i--);
						  M_POUT_OFF ;
						  houtuicn=houtuicn+1;   
						  
						 i=100;
						  while(i--);
						  
						  M_POUT_ON ;
						 i=100;
						  while(i--);
						  M_POUT_OFF ;
						  houtuicn=houtuicn+1;      
						   
						 i=100;
						 while(i--);
						  
						  M_POUT_ON ;
						   i=100;
						 while(i--);
						  M_POUT_OFF ;
						  houtuicn=houtuicn+1;      
						  
					   //   flagyunxing8=1;
						  
						}
						
					}
					  
					 
				if(xa==0&&xb==0)
					{
					 if(xa1==0&&xb1==1)
						{ 
						InTargetPosit_flag=0;
						 //   BellOUT_OFF;   
							M_DOUT_ON ;
						
						 //  M_POUT_ON ;
						//   i=100;
						 ////  while(i--);
						 //  M_POUT_OFF ;
						 //  qianjincn=qianjincn+1;   
					  
							i=100;
						  while(i--);
						  
						   M_POUT_ON ;
						   i=100;
						  while(i--);
						  M_POUT_OFF ;
						  qianjincn=qianjincn+1;  
						   
							i=100;
						 while(i--);
						  
						  M_POUT_ON ;
						   i=100;
						 while(i--);
						  M_POUT_OFF ;
						  qianjincn=qianjincn+1;  
					  
							  i=100;
						 while(i--);
						  
						  M_POUT_ON ;
						   i=100;
						 while(i--);
						  M_POUT_OFF ;
						  qianjincn=qianjincn+1;  
					  
					 //  flagyunxing8=1;
						}
						  
					}
					 
				xa=xa1;
				xb=xb1;    
				}
				
				
			}
		
			
			break;		
	}
     
          
  MsTime++;
  if(MsTime>=20)
	{
	 MsTime=0;
	 Ms_Flag=1;
	 SysTime++;
        
         chengxuTime++;
         
         sys_tick++;
         
         if( flaglaba==1)
            {
            labatime++;
             if(labatime>200)
               {
               labatime=0;
               flaglaba=0;
               BellOUT_OFF;
               }
             }
         
          
        if(CutEnBegin_flag==1)
			{
			CutDelayTime++;
			if(CutDelayTime>400)
				{
				CutEnBegin_flag=0;
				BellOUT_OFF;
				RLOUT4_ON;
						AutoCutStart_flag=0;
						RunStop_flag=0;
						Run_flag=0;
						
				}
				
			}
		
        /*
         if( chengxuTime>300)
         {
            chengxuTime=0;
            chengxu_Flag=!chengxu_Flag;
           
           
         } 
         
       xianshitime++;
         if( xianshitime>3000)
         {
             xianshitime=0;
            xianshi_Flag=!xianshi_Flag;
           
           
         }
        
		 */
	 if(SysTime>=10)
		{
		 SysTime=0;
                //// Bcd[3]++;
	       // if(Bcd[3]>9)
		// Bcd[3]=0;

                 sysflag=1;
                 
                 
		}
	}

}

void Timer0Init(void)
{

		Timer0_Config();
		/*
//user code start
 //user code end
  // Enable TIM0 clocks
  PCONP_bit.PCTIM0 = 1; // enable clock
  // Init Time0
  T0TCR_bit.CE = 0;     // counting  disable
  T0TCR_bit.CR = 1;     // set reset
  T0TCR_bit.CR = 0;     // release reset
  T0CTCR_bit.CTM = 0;   // Timer Mode: every rising PCLK edge
  T0MCR_bit.MR0I = 1;   // Enable Interrupt on MR0
  T0MCR_bit.MR0R = 1;   // Enable reset on MR0
  T0MCR_bit.MR0S = 0;   // Disable stop on MR0
  // set timer 0 period
  T0PR = 0;
  T0MR0 = SYS_GetFpclk(TIMER0_PCLK_OFFSET)/(TIMER0_TICK_PER_SEC);
  // init timer 0 interrupt
  T0IR_bit.MR0INT = 1;  // clear pending interrupt
  VIC_SetVectoredIRQ(Timer0IntrHandler,TIMER0_PRIORITY,VIC_TIMER0);
  VICINTENABLE |= 1UL << VIC_TIMER0;
  T0TCR_bit.CE = 1;     // counting Enable
  __enable_interrupt();
  */
}

void Timer0Disable(void)  //定时器0禁止
{
		ETimer0_Close();
		/*
 T0TCR_bit.CE = 0;     // counting Enable
 VICINTENCLEAR |= 1UL << VIC_TIMER0;
 */
}


void Timer1IntrHandler(void)
{
  unsigned long int i;
//user code start

    Ms_Flag=1;
  if(houtui==1)
	{     
    qianjin=0;  

	if(WorkStart_flag==1)
		outpw(REG_ETMR1_CMPR,(0xffff- waitTemp[step_add]));	//T1MR1 =(0xffff- waitTemp[step_add]);
	else
		outpw(REG_ETMR1_CMPR,(0xffff- waitTb4[step_add]));//T1MR1 =(0xffff- waitTb4[step_add]);
	
    M_DOUT_OFF ;
    
    M_POUT_ON ;
    i=25;
    while(i--);
    M_POUT_OFF ;
     
	houtuicn=houtuicn+1; 
  
    }
  
  if(qianjin==1)
	{     
    houtui=0;  

	if(WorkStart_flag==1)
		outpw(REG_ETMR1_CMPR,(0xffff- waitTemp[step_add]));	//T1MR1 =(0xffff- waitTemp[step_add]);
	else
		outpw(REG_ETMR1_CMPR,(0xffff- waitTb4[step_add]));//T1MR1 =(0xffff- waitTb4[step_add]);
	    
    M_DOUT_ON ;
    
    M_POUT_ON ;
    i=25;
    while(i--);
    M_POUT_OFF ;
     
	qianjincn=qianjincn+1; 
  
    }
   
 if(status==9)         
   {
    rollsteps=rollsteps-1;
    if(rollsteps==0)
		{
        flagtingji8=1;
        flagyunxing8=0; 
       
         status=8; 
       //  flagtingji7=1;
        t0zhongduan=0;
    
        keytingji=0;
    
        Timer1Disable();
         
       }
   }
  
 if(status==1)         //加速阶段
   {
     step_ground--;
     if(step_ground==0)
       {
        step_ground=11;
        step_add++;
        speedup_steps--;
        if(speedup_steps==0)
          {
   //          rollsteps--;
             status=2;
          }
        
       }
 
   
   }
  
  if(status==2)
   {  
    if(flagqyx==0)
      {
       rollsteps=rollsteps-1;
       step_add= speedup_steps_B;
       if(rollsteps==0)
		{
         speedup_steps=speedup_steps_B;
         step_ground=11;
         status=4;
		}
      }
   
   }
  
  if(status==4)
  {
   step_ground=step_ground-1;;    
   if(step_ground==0)
     {
      step_ground=11;
      step_add--;
      
      speedup_steps--;
      
      
      if(speedup_steps==0)
       {
         status=8; 
       
         flagtingji8=1;     
          flagyunxing8=0; 
         t0zhongduan=0;
         flagone=0;
   ///////////////////////////////////// 
       Timer1Disable();
       if(qianjin==1)
       {
       flagbeep=1;
       }
       //  Timer0Init();
       }
     
     }
  
  }
  
  
  
 if(flaglaba==1)
        {
        labatime++;
        if(labatime>1200)
               {
               labatime=0;
               flaglaba=0;
               BellOUT_OFF;
               }
        } 
  /*
 T1MR1 =(0xffff- waitTb8[10]);
 
   M_DOUT_OFF ;
   
   M_POUT_ON ;
   i=100;
 while(i--);
   M_POUT_OFF ;
  */		


}

void Timer1Init(void)
{

	Timer1_Config();
	/*
//user code start
 //user code end
  // Enable TIM0 clocks
  PCONP_bit.PCTIM1 = 1; // enable clock
  // Init Time0
  T1TCR_bit.CE = 0;     // counting  disable
  T1TCR_bit.CR = 1;     // set reset
  T1TCR_bit.CR = 0;     // release reset
  T1CTCR_bit.CTM = 0;   // Timer Mode: every rising PCLK edge
  T1MCR_bit.MR1I = 1;   // Enable Interrupt on MR0
  T1MCR_bit.MR1R = 1;   // Enable reset on MR0
  T1MCR_bit.MR1S = 0;   // Disable stop on MR0
  // set timer 0 period
  T1PR = 1;
  T1MR1 = SYS_GetFpclk(TIMER1_PCLK_OFFSET)/(TIMER1_TICK_PER_SEC);
  // init timer 0 interrupt
  T1IR_bit.MR1INT = 1;  // clear pending interrupt
  VIC_SetVectoredIRQ(Timer1IntrHandler,TIMER1_PRIORITY,VIC_TIMER1);
  VICINTENABLE |= 1UL << VIC_TIMER1;
  T1TCR_bit.CE = 1;     // counting Enable
  __enable_interrupt();
  */
}


void Timer1Disable(void)  //定时器1禁止
{
	ETimer1_Close();
	
	/*

 T1TCR_bit.CE = 0;     // counting Enable
 VICINTENCLEAR|= 1UL << VIC_TIMER1;

 */
}




//-------------------------------------------------------
void ACServoMoveBack_MID_SPD(void)  //交流伺服  中速后退
{
 houtui=1;
qianjin=0;   

step_add=10;   

step_ground=11; 

speedup_steps=40;
status=1;
 flagqyx=2;
 
Timer1Init();
Timer0Disable(); 
//BellOUT_OFF;

RLOUT1_ON;    // 允许裁切断开
CutPermit_flag=0;
}

void ACServoMoveBack_LOW_SPD(void)  //交流伺服  低速后退
{
step_add=50;
step_ground=11; 
speedup_steps=40;  

status=4;   

 Timer1Init();
Timer0Disable(); 
//BellOUT_OFF;

RLOUT1_ON;    // 允许裁切断开
CutPermit_flag=0;
}

void ACServoStop(void)  //交流伺服	停止
{
flagtingji8=1;     
flagyunxing8=0; 
t0zhongduan=0;
flagone=0;
flagqyx=0;
Timer1Disable();
Timer0Init(); 
if(flagyd==1)
	{
	 flagyd=0;
	}
	
RunStop_flag=0;
LowerAC_SPD_flag=0;

RLOUT1_OFF;    // 允许裁切------------------++++++++++++++
}


/*
void ExtInt1IntrHandler(void)  //外部中断ISR
{

  WDFEED = 0xaa;
  WDFEED = 0x55;

  
    
   Timer1Disable();
dem++;
Temp11++;
 status=12;
 poweon_flag=0;
 chushihua=1;
  qianjincn=0;
   houtuicn=0; 
  flagtingji8=1; 
    houtui=0;
    qianjin=1;
 
muqiancn=yuandiancn;


 IO2INTENF&=~(1<<11);//关中断

  
  VICADDRESS = 0;
}
*/

void ExtInt1Init(void)  //外部中断初始化
{
  /*
  PINSEL4 &= ~(1<<22|1<<23);//
  PINSEL4 |= (1<<22|0<<23);

  
  
FIO2DIR&=~(1<<11);
  IO2INTENF&=~(1<<11);//关中断

//IO2INTENF|=(1<<11);  //开放EXTINT1 下降沿中断

VICINTENCLEAR |= 1<< VIC_EINT3;
VIC_SetVectoredIRQ(ExtInt1IntrHandler,0,VIC_EINT3);  //开外部1中断  最高优先级
VICINTENABLE |= 1<< VIC_EINT3;
__enable_interrupt();

*/
}

/*
void ExtInt1IntrHandler(void)  //外部中断ISR
{

	 EXTINT|=(1<<EINT1); //清除标志位 
	 Bcd[3]++;
	 if(Bcd[3]>9)
		 Bcd[3]=0;
  VICADDRESS = 0;
}


void ExtInt1Init(void)  //外部中断初始化
{
EXTMODE=(1<<EXTMODE1);    //EINT1 边沿触发
EXTPOLAR=(1<<EXTPOLAR1); //EINT1  下降沿有效
VIC_SetVectoredIRQ(ExtInt1IntrHandler,0,VIC_EINT1);  //开外部1中断  最高优先级
VICINTENABLE |= ( 1<< VIC_EINT1);
__enable_interrupt();
}

*/










void AC_ChangeSPD(void)  
{
if(flagqyx==1)
	{
	 step_add=10;      
	  step_ground=11; 

	  speedup_steps=30;
	  status=1;      
	  houtui=0; 
	}    
}

void ACMotorRunStart(Int32U vbcd)//  AC伺服  运行启动
{    
Int32U tempqianjin1;    
Int32U temphoutui1;    
if(vbcd<CurrentSize)
	{ 
	tempqianjin1=(CurrentSize-vbcd)*2;

    rollsteps=tempqianjin1-yushu;
    qianjin=1;
    houtui=0;  
	
	RLOUT1_ON;    // 允许裁切断开
	CutPermit_flag=0;
	}  
else if(vbcd>CurrentSize)
    {
	 temphoutui1=(vbcd-CurrentSize)*2;

	 rollsteps=temphoutui1+yushu;
	 houtui=1;
	 qianjin=0;
	 
	RLOUT1_ON;    // 允许裁切断开
	CutPermit_flag=0; 
    }  
else
    {
	qianjin=0;
    houtui=0;
	}   
          
if(houtui==1)
    {     
	step_ground=11; 
	rollsteps=rollsteps+2400;    
        
	if(rollsteps>3000)
		{
	   speedup_steps=100;  
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;      
		
		}
	else if(rollsteps>2000&&rollsteps<3001)
		{  
		speedup_steps=45; 
		speedup_steps_B=speedup_steps;
		rollsteps=(rollsteps- speedup_steps*22)+2;
		status=1;  
		  
		
		}                                                               
	else if(rollsteps>1000&&rollsteps<2001)
		{
	   speedup_steps=30; 
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;  
						
		} 
	else if(rollsteps>500&&rollsteps<1001)
		{
	   speedup_steps=20;
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;  
					
		}   
	else  if(rollsteps>100&&rollsteps<501)
		{
		speedup_steps=4;   
		speedup_steps_B=speedup_steps;
		rollsteps=(rollsteps- speedup_steps*22)+2;
		status=1;  
			
		}
	else
		{  
		   status=9;    
		   step_add=1;  
		   
	 //       speedup_steps=1;
		}
          
	flagtingji8=0;
	flagyunxing8=1;
	step_add=1;     

	Timer1Init();
	Timer0Disable();
    }  
            
            
if(qianjin==1)//----------------------------------------------------------
    {
     step_ground=11;  
  
	if(rollsteps>3000)
		{
	   speedup_steps=100;  
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;  
	  
		}
	else if(rollsteps>2000&&rollsteps<3001)
		{
		speedup_steps=45;
		speedup_steps_B=speedup_steps;
		rollsteps=(rollsteps- speedup_steps*22)+2;
		status=1;   
	   
		}
	else if(rollsteps>1000&&rollsteps<2001)
		{
	   speedup_steps=30;
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;   
				
		} 
	else if(rollsteps>500&&rollsteps<1001)
		{
	   speedup_steps=20;
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;   
				  
		}   
	else  if(rollsteps>100&&rollsteps<501)
		{
		speedup_steps=4;  
		speedup_steps_B=speedup_steps;
		rollsteps=(rollsteps- speedup_steps*22)+2;
		status=1;  
		 
		}
	else
		{    
		status=9; 
		step_add=1;  
		 
	 //       speedup_steps=1;
		}
	
	 flagtingji8=0;     
	 flagyunxing8=1;
	 step_add=1;     

	Timer1Init();
	Timer0Disable();
	
	}
    
}


void ACMotorGoForward(void)  //前进
{
flagyd=1;       
flagqyx=1;

qianjin=1;

step_add=25;      
step_ground=11; 

speedup_steps=30;
status=1;      
houtui=0; 
 
flagtingji8=0;
flagyunxing8=1;      

Timer1Init();
Timer0Disable();

RLOUT1_ON;    // 允许裁切断开
CutPermit_flag=0;
}

void ACMotorGoBack(void)  //后退
{
 qianjin=0;
flagqyx=2;
 flagyd=1;

step_add=25;   
step_ground=11; 

speedup_steps=30;
houtui=1;   
status=1;

flagtingji8=0;
flagyunxing8=1;  

Timer1Init();
Timer0Disable();

RLOUT1_ON;    // 允许裁切断开
CutPermit_flag=0;
}

void ACMotorGoFastForward(void)  // 快进
{
flagyd=1;       
flagqyx=1;

qianjin=1;

step_add=60;      
step_ground=11; 

speedup_steps=30;
status=1;      
houtui=0; 
 
flagtingji8=0;
flagyunxing8=1;      

Timer1Init();
Timer0Disable();

RLOUT1_ON;    // 允许裁切断开
CutPermit_flag=0;
}

void ACMotorGoFastBack(void)  //快退
{   
 qianjin=0;
flagqyx=2;
 flagyd=1;

step_add=60;   
step_ground=11; 

speedup_steps=30;
houtui=1; 
status=1;

flagtingji8=0;
flagyunxing8=1;  

Timer1Init();
Timer0Disable();

RLOUT1_ON;    // 允许裁切断开
CutPermit_flag=0;
}


void ACMotor_ReleaseStop(void)
{
flagkey=0;
flagkeysong=1;
// flagyici=0;
 flagtime1=0;
flagyunxing8=0;
/*
if(flagyd==1)
	{
	 flagyd=0;
	 
	   flagzhiyou=0;
	   flagtingji8=1;
	   flagyunxing8=0;
	  // keytingji=0;
	   flagqyx=0;
  
	  flagtingji8=1;
   
	 Timer1Disable();
	 Timer0Init();
	}
	*/
}