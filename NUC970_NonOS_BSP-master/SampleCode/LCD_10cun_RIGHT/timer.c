

#include "port.h"

#include "main.h"



#include"pic_exec.h"

#include "key.h"

#include "io.h"


#include "sys.h"
#include "timer.h"
#include"drv_glcd.h"

#include "timer_config.h"



#define TIMER0_TICK_PER_SEC 20000

#define TIMER1_TICK_PER_SEC   5000  //10




#define TIMER2_TICK_PER_SEC 10
#define TIMER3_TICK_PER_SEC 10

//中断优先级
#define TIMER0_PRIORITY 3
#define TIMER1_PRIORITY 2
#define TIMER2_PRIORITY 4
#define TIMER3_PRIORITY 5
#define LED1DIR 1ul<<13
#define LED1ANTI 1ul<<13

Int32U MsTime;
char Ms_Flag,Temp11, sysflag;
unsigned  char chushihua,tmpzidong;


char flagone;
Int32U SysTime;
Int32U sys_tick;


unsigned long int dem;
unsigned char z_mode,a,b,xa,xb,xa1,xb1,flagqianjin,flaghoutui,flaghq;
unsigned  long int  muqiancn,xsmuqiancn, yuandiancn;
unsigned char  chengxu_Flag,xianshi_Flag,flaglaba,daowei;
unsigned char keytingji,xz,xs,senor,flagqianjin2,flagsenor,flagyqjixian,flagyhjixian,flagyzjixian;
  int   chengxuTime,xianshitime,labatime;
//unsigned long int vbcd;

unsigned char  xsenor1;


//**************脉冲发送变量**********************//
 
Int32U Current_last;

Int32U MotorSpeed;
Int16U SpeedCou;

Int8U ToTargetStop_flag;

Int8U StopDelay_flag;
Int16U StopDelayCou;

Int8U CutEnBegin_flag;
Int16U CutDelayTime;

Int8U FreqMotorStop_flag;

unsigned char  flagbeep;
Int8U flagshoulun;

Int32U waitTemp[120];
Int8U LowerAC_SPD_flag;

static INT_32 timer0dev, timer1dev;
Int32U Z_code_error;
Int8U Z_code_err_time;
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1200;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1000;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb1[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xE838, 0xEB5F, 0xEDCA, 0xEFB3, 0xF13F, 0xF287, 0xF39B, 0xF486, 0xF551,  // 60
	0xF601, 0xF69D, 0xF726, 0xF7A1, 0xF80F, 0xF873, 0xF8CD, 0xF91F, 0xF96A, 0xF9B0,  // 70
	0xF9EF, 0xFA2A, 0xFA61, 0xFA94, 0xFAC3, 0xFAEF, 0xFB19, 0xFB40, 0xFB64, 0xFB87,  // 80
	0xFBA8, 0xFBC6, 0xFBE3, 0xFBFF, 0xFC19, 0xFC32, 0xFC4A, 0xFC61, 0xFC76, 0xFC8B,  // 90
	0xFC9E, 0xFCB1, 0xFCC3, 0xFCD5, 0xFCE5, 0xFCF5, 0xFD05, 0xFD13, 0xFD22, 0xFD2F,  // 100
	0xFD3D, 0xFD44, 0xFD4B, 0xFD53, 0xFD5A, 0xFD61, 0xFD67, 0xFD6E, 0xFD74, 0xFD7B,  // 110
	0xFD81, 0xFD87, 0xFD8D, 0xFD93, 0xFD99, 0xFD9F, 0xFDA4, 0xFDAA, 0xFDAF, 0xFDB4 // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1400;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1200;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb2[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xE8FE, 0xEC84, 0xEF1C, 0xF116, 0xF2A8, 0xF3ED, 0xF4FA, 0xF5DC, 0xF69D,  // 60
	0xF742, 0xF7D3, 0xF853, 0xF8C3, 0xF928, 0xF982, 0xF9D4, 0xFA1E, 0xFA61, 0xFA9E,  // 70
	0xFAD7, 0xFB0B, 0xFB3C, 0xFB68, 0xFB92, 0xFBB9, 0xFBDD, 0xFBFF, 0xFC1F, 0xFC3D,  // 80
	0xFC59, 0xFC74, 0xFC8D, 0xFCA5, 0xFCBB, 0xFCD1, 0xFCE5, 0xFCF9, 0xFD0B, 0xFD1D,  // 90
	0xFD2E, 0xFD3E, 0xFD4D, 0xFD5C, 0xFD6A, 0xFD78, 0xFD85, 0xFD92, 0xFD9E, 0xFDA9,  // 100
	0xFDB4, 0xFDBA, 0xFDBF, 0xFDC4, 0xFDC9, 0xFDCE, 0xFDD3, 0xFDD7, 0xFDDC, 0xFDE0,  // 110
	0xFDE5, 0xFDE9, 0xFDEE, 0xFDF2, 0xFDF6, 0xFDFA, 0xFDFE, 0xFE02, 0xFE06, 0xFE0A // 120
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1600;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1400;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb3[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xE9BA, 0xED8B, 0xF040, 0xF243, 0xF3D2, 0xF510, 0xF613, 0xF6EB, 0xF7A1,  // 60
	0xF83C, 0xF8C3, 0xF939, 0xF9A1, 0xF9FD, 0xFA4F, 0xFA99, 0xFADC, 0xFB19, 0xFB50,  // 70
	0xFB83, 0xFBB2, 0xFBDD, 0xFC05, 0xFC2A, 0xFC4C, 0xFC6D, 0xFC8B, 0xFCA7, 0xFCC1,  // 80
	0xFCDA, 0xFCF2, 0xFD08, 0xFD1D, 0xFD31, 0xFD44, 0xFD56, 0xFD67, 0xFD77, 0xFD86,  // 90
	0xFD95, 0xFDA3, 0xFDB0, 0xFDBD, 0xFDCA, 0xFDD6, 0xFDE1, 0xFDEC, 0xFDF6, 0xFE00,  // 100
	0xFE0A, 0xFE0E, 0xFE12, 0xFE16, 0xFE19, 0xFE1D, 0xFE20, 0xFE24, 0xFE27, 0xFE2B,  // 110
	0xFE2E, 0xFE31, 0xFE35, 0xFE38, 0xFE3B, 0xFE3E, 0xFE41, 0xFE45, 0xFE48, 0xFE4B // 120
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1800;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1600;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb4[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xEA6B, 0xEE79, 0xF13F, 0xF344, 0xF4CD, 0xF601, 0xF6FA, 0xF7C7, 0xF873,  // 60
	0xF905, 0xF982, 0xF9EF, 0xFA4F, 0xFAA4, 0xFAEF, 0xFB33, 0xFB70, 0xFBA8, 0xFBDA,  // 70
	0xFC08, 0xFC32, 0xFC59, 0xFC7D, 0xFC9E, 0xFCBD, 0xFCDA, 0xFCF5, 0xFD0F, 0xFD26,  // 80
	0xFD3D, 0xFD51, 0xFD65, 0xFD78, 0xFD8A, 0xFD9A, 0xFDAA, 0xFDB9, 0xFDC8, 0xFDD6,  // 90
	0xFDE3, 0xFDEF, 0xFDFB, 0xFE07, 0xFE11, 0xFE1C, 0xFE26, 0xFE30, 0xFE39, 0xFE42,  // 100
	0xFE4B, 0xFE4D, 0xFE50, 0xFE53, 0xFE56, 0xFE59, 0xFE5C, 0xFE5E, 0xFE61, 0xFE64,  // 110
	0xFE66, 0xFE69, 0xFE6B, 0xFE6E, 0xFE70, 0xFE73, 0xFE75, 0xFE78, 0xFE7A, 0xFE7C // 120
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2000;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1800;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb5[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xEB0F, 0xEF4F, 0xF220, 0xF421, 0xF5A2, 0xF6CC, 0xF7BA, 0xF87D, 0xF91F,  // 60
	0xF9A8, 0xFA1E, 0xFA83, 0xFADC, 0xFB2A, 0xFB70, 0xFBAE, 0xFBE7, 0xFC19, 0xFC47,  // 70
	0xFC71, 0xFC98, 0xFCBB, 0xFCDC, 0xFCFA, 0xFD17, 0xFD31, 0xFD49, 0xFD60, 0xFD76,  // 80
	0xFD8A, 0xFD9D, 0xFDAE, 0xFDBF, 0xFDCF, 0xFDDE, 0xFDED, 0xFDFA, 0xFE07, 0xFE14,  // 90
	0xFE1F, 0xFE2B, 0xFE35, 0xFE40, 0xFE49, 0xFE53, 0xFE5C, 0xFE64, 0xFE6D, 0xFE75,  // 100
	0xFE7C, 0xFE7F, 0xFE81, 0xFE83, 0xFE86, 0xFE88, 0xFE8A, 0xFE8C, 0xFE8E, 0xFE91,  // 110
	0xFE93, 0xFE95, 0xFE97, 0xFE99, 0xFE9B, 0xFE9D, 0xFE9F, 0xFEA1, 0xFEA3, 0xFEA4 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2200;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2000;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb6[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xEBAB, 0xF011, 0xF2E8, 0xF4E3, 0xF65A, 0xF77A, 0xF85D, 0xF916, 0xF9B0,  // 60
	0xFA30, 0xFA9E, 0xFAFE, 0xFB50, 0xFB99, 0xFBDA, 0xFC14, 0xFC47, 0xFC76, 0xFCA1,  // 70
	0xFCC7, 0xFCEB, 0xFD0B, 0xFD29, 0xFD45, 0xFD5F, 0xFD77, 0xFD8D, 0xFDA2, 0xFDB5,  // 80
	0xFDC8, 0xFDD9, 0xFDE9, 0xFDF9, 0xFE07, 0xFE15, 0xFE22, 0xFE2E, 0xFE3A, 0xFE45,  // 90
	0xFE50, 0xFE5A, 0xFE64, 0xFE6D, 0xFE76, 0xFE7F, 0xFE87, 0xFE8F, 0xFE96, 0xFE9E,  // 100
	0xFEA4, 0xFEA6, 0xFEA8, 0xFEAA, 0xFEAC, 0xFEAE, 0xFEB0, 0xFEB1, 0xFEB3, 0xFEB5,  // 110
	0xFEB7, 0xFEB8, 0xFEBA, 0xFEBC, 0xFEBD, 0xFEBF, 0xFEC0, 0xFEC2, 0xFEC4, 0xFEC5 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2400;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2200;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb7[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xEC3F, 0xF0C4, 0xF39B, 0xF58E, 0xF6FA, 0xF80F, 0xF8E9, 0xF999, 0xFA2A,  // 60
	0xFAA4, 0xFB0B, 0xFB64, 0xFBB2, 0xFBF6, 0xFC32, 0xFC68, 0xFC98, 0xFCC3, 0xFCEB,  // 70
	0xFD0F, 0xFD2F, 0xFD4D, 0xFD69, 0xFD83, 0xFD9A, 0xFDB0, 0xFDC5, 0xFDD8, 0xFDEA,  // 80
	0xFDFB, 0xFE0B, 0xFE1A, 0xFE28, 0xFE35, 0xFE42, 0xFE4E, 0xFE59, 0xFE64, 0xFE6E,  // 90
	0xFE78, 0xFE81, 0xFE8A, 0xFE93, 0xFE9B, 0xFEA3, 0xFEAA, 0xFEB1, 0xFEB8, 0xFEBF,  // 100
	0xFEC5, 0xFEC7, 0xFEC8, 0xFECA, 0xFECB, 0xFECD, 0xFECE, 0xFED0, 0xFED1, 0xFED3,  // 110
	0xFED4, 0xFED6, 0xFED7, 0xFED8, 0xFEDA, 0xFEDB, 0xFEDD, 0xFEDE, 0xFEDF, 0xFEE0 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2600;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2400;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb8[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xECC8, 0xF166, 0xF43C, 0xF625, 0xF787, 0xF892, 0xF962, 0xFA0A, 0xFA94,  // 60
	0xFB07, 0xFB68, 0xFBBC, 0xFC05, 0xFC45, 0xFC7D, 0xFCAF, 0xFCDC, 0xFD05, 0xFD29,  // 70
	0xFD4B, 0xFD69, 0xFD85, 0xFD9F, 0xFDB7, 0xFDCC, 0xFDE1, 0xFDF4, 0xFE06, 0xFE16,  // 80
	0xFE26, 0xFE35, 0xFE42, 0xFE50, 0xFE5C, 0xFE67, 0xFE72, 0xFE7D, 0xFE87, 0xFE90,  // 90
	0xFE99, 0xFEA2, 0xFEAA, 0xFEB2, 0xFEBA, 0xFEC1, 0xFEC8, 0xFECE, 0xFED5, 0xFEDB,  // 100
	0xFEE0, 0xFEE2, 0xFEE3, 0xFEE4, 0xFEE6, 0xFEE7, 0xFEE8, 0xFEE9, 0xFEEB, 0xFEEC,  // 110
	0xFEED, 0xFEEE, 0xFEEF, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4, 0xFEF5, 0xFEF6, 0xFEF8 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2800;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2600;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb9[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xED4C, 0xF1FC, 0xF4CD, 0xF6AC, 0xF803, 0xF905, 0xF9CC, 0xFA6C, 0xFAEF,  // 60
	0xFB5C, 0xFBB9, 0xFC08, 0xFC4C, 0xFC88, 0xFCBD, 0xFCEC, 0xFD17, 0xFD3D, 0xFD5F,  // 70
	0xFD7E, 0xFD9A, 0xFDB4, 0xFDCC, 0xFDE3, 0xFDF7, 0xFE0A, 0xFE1C, 0xFE2C, 0xFE3C,  // 80
	0xFE4B, 0xFE58, 0xFE65, 0xFE71, 0xFE7C, 0xFE87, 0xFE92, 0xFE9B, 0xFEA4, 0xFEAD,  // 90
	0xFEB6, 0xFEBE, 0xFEC5, 0xFECC, 0xFED3, 0xFEDA, 0xFEE0, 0xFEE7, 0xFEED, 0xFEF2,  // 100
	0xFEF8, 0xFEF9, 0xFEFA, 0xFEFB, 0xFEFC, 0xFEFD, 0xFEFE, 0xFEFF, 0xFF00, 0xFF01,  // 110
	0xFF02, 0xFF03, 0xFF04, 0xFF05, 0xFF06, 0xFF07, 0xFF08, 0xFF09, 0xFF0A, 0xFF0B // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3000;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2800;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb10[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xEDCA, 0xF287, 0xF551, 0xF726, 0xF873, 0xF96A, 0xFA2A, 0xFAC3, 0xFB40,  // 60
	0xFBA8, 0xFBFF, 0xFC4A, 0xFC8B, 0xFCC3, 0xFCF5, 0xFD22, 0xFD49, 0xFD6D, 0xFD8D,  // 70
	0xFDAA, 0xFDC5, 0xFDDE, 0xFDF4, 0xFE09, 0xFE1C, 0xFE2E, 0xFE3E, 0xFE4E, 0xFE5C,  // 80
	0xFE6A, 0xFE77, 0xFE83, 0xFE8E, 0xFE99, 0xFEA3, 0xFEAC, 0xFEB5, 0xFEBE, 0xFEC6,  // 90
	0xFECE, 0xFED5, 0xFEDC, 0xFEE3, 0xFEEA, 0xFEF0, 0xFEF6, 0xFEFC, 0xFF01, 0xFF06,  // 100
	0xFF0B, 0xFF0C, 0xFF0D, 0xFF0E, 0xFF0F, 0xFF10, 0xFF11, 0xFF12, 0xFF13, 0xFF14,  // 110
	0xFF15, 0xFF16, 0xFF16, 0xFF17, 0xFF18, 0xFF19, 0xFF1A, 0xFF1B, 0xFF1C, 0xFF1C // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3200;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 3000;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb11[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xEE3F, 0xF307, 0xF5C9, 0xF794, 0xF8D6, 0xF9C5, 0xFA7E, 0xFB10, 0xFB87,  // 60
	0xFBEA, 0xFC3D, 0xFC84, 0xFCC1, 0xFCF7, 0xFD26, 0xFD50, 0xFD76, 0xFD97, 0xFDB5,  // 70
	0xFDD1, 0xFDEA, 0xFE01, 0xFE16, 0xFE2A, 0xFE3C, 0xFE4D, 0xFE5C, 0xFE6B, 0xFE78,  // 80
	0xFE85, 0xFE91, 0xFE9C, 0xFEA7, 0xFEB1, 0xFEBA, 0xFEC3, 0xFECC, 0xFED4, 0xFEDC,  // 90
	0xFEE3, 0xFEEA, 0xFEF1, 0xFEF7, 0xFEFD, 0xFF03, 0xFF08, 0xFF0E, 0xFF13, 0xFF18,  // 100
	0xFF1C, 0xFF1D, 0xFF1E, 0xFF1F, 0xFF20, 0xFF21, 0xFF21, 0xFF22, 0xFF23, 0xFF24,  // 110
	0xFF25, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2B // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3400;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 3200;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb12[]={
	0xC7C7, 0xC8E7, 0xC9FC, 0xCAF6, 0xCBF7, 0xCCEE, 0xCDCF, 0xCEB5, 0xCF93, 0xD05D,  // 10
	0xD12C, 0xD1F5, 0xD2AC, 0xD368, 0xD41E, 0xD4C4, 0xD56F, 0xD615, 0xD6AD, 0xD74A,  // 20
	0xD7E2, 0xD86D, 0xD8FC, 0xD988, 0xDA08, 0xDA8C, 0xDB0D, 0xDB83, 0xDBFE, 0xDC75,  // 30
	0xDCE2, 0xDD54, 0xDDC2, 0xDE28, 0xDE91, 0xDEF8, 0xDF56, 0xDFB9, 0xE019, 0xE071,  // 40
	0xE0CC, 0xE126, 0xE179, 0xE1CF, 0xE223, 0xE270, 0xE2C0, 0xE30F, 0xE358, 0xE3A4,  // 50
	0xE3EE, 0xEEB0, 0xF37E, 0xF637, 0xF7F8, 0xF930, 0xFA17, 0xFAC8, 0xFB54, 0xFBC6,  // 60
	0xFC24, 0xFC74, 0xFCB7, 0xFCF2, 0xFD25, 0xFD51, 0xFD79, 0xFD9D, 0xFDBC, 0xFDD9,  // 70
	0xFDF3, 0xFE0B, 0xFE21, 0xFE35, 0xFE47, 0xFE58, 0xFE68, 0xFE77, 0xFE84, 0xFE91,  // 80
	0xFE9D, 0xFEA8, 0xFEB3, 0xFEBD, 0xFEC6, 0xFECF, 0xFED8, 0xFEE0, 0xFEE7, 0xFEEF,  // 90
	0xFEF5, 0xFEFC, 0xFF02, 0xFF08, 0xFF0E, 0xFF13, 0xFF19, 0xFF1E, 0xFF22, 0xFF27,  // 100
	0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF31, 0xFF32,  // 110
	0xFF33, 0xFF33, 0xFF34, 0xFF35, 0xFF35, 0xFF36, 0xFF37, 0xFF37, 0xFF38, 0xFF39 // 120
	
};

//------------------增加12档

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1200;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1000;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb13[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF421, 0xF5B5, 0xF6EB, 0xF7DF, 0xF8A6, 0xF94A, 0xF9D4, 0xFA49, 0xFAAE,  // 60
	0xFB07, 0xFB54, 0xFB99, 0xFBD7, 0xFC0E, 0xFC40, 0xFC6D, 0xFC96, 0xFCBB, 0xFCDE,  // 70
	0xFCFE, 0xFD1B, 0xFD37, 0xFD50, 0xFD68, 0xFD7E, 0xFD93, 0xFDA6, 0xFDB8, 0xFDCA,  // 80
	0xFDDA, 0xFDE9, 0xFDF8, 0xFE06, 0xFE13, 0xFE1F, 0xFE2B, 0xFE37, 0xFE41, 0xFE4C,  // 90
	0xFE55, 0xFE5F, 0xFE68, 0xFE71, 0xFE79, 0xFE81, 0xFE89, 0xFE90, 0xFE97, 0xFE9E,  // 100
	0xFEA4, 0xFEA8, 0xFEAC, 0xFEB0, 0xFEB3, 0xFEB7, 0xFEBA, 0xFEBD, 0xFEC0, 0xFEC4,  // 110
	0xFEC7, 0xFECA, 0xFECD, 0xFED0, 0xFED3, 0xFED6, 0xFED8, 0xFEDB, 0xFEDE, 0xFEE0 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1400;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1200;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb14[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF486, 0xF648, 0xF794, 0xF892, 0xF95A, 0xF9FD, 0xFA83, 0xFAF4, 0xFB54,  // 60
	0xFBA8, 0xFBF0, 0xFC2F, 0xFC68, 0xFC9A, 0xFCC7, 0xFCF0, 0xFD15, 0xFD37, 0xFD56,  // 70
	0xFD72, 0xFD8C, 0xFDA4, 0xFDBA, 0xFDCF, 0xFDE3, 0xFDF5, 0xFE06, 0xFE16, 0xFE25,  // 80
	0xFE33, 0xFE40, 0xFE4D, 0xFE59, 0xFE64, 0xFE6F, 0xFE79, 0xFE83, 0xFE8C, 0xFE95,  // 90
	0xFE9D, 0xFEA5, 0xFEAD, 0xFEB4, 0xFEBB, 0xFEC2, 0xFEC9, 0xFECF, 0xFED5, 0xFEDB,  // 100
	0xFEE0, 0xFEE3, 0xFEE6, 0xFEE8, 0xFEEB, 0xFEED, 0xFEEF, 0xFEF2, 0xFEF4, 0xFEF6,  // 110
	0xFEF9, 0xFEFB, 0xFEFD, 0xFEFF, 0xFF01, 0xFF03, 0xFF05, 0xFF07, 0xFF09, 0xFF0B // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1600;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1400;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb15[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF4E3, 0xF6CC, 0xF826, 0xF928, 0xF9EF, 0xFA8E, 0xFB10, 0xFB7C, 0xFBD7,  // 60
	0xFC24, 0xFC68, 0xFCA3, 0xFCD7, 0xFD05, 0xFD2E, 0xFD53, 0xFD74, 0xFD93, 0xFDAE,  // 70
	0xFDC8, 0xFDDF, 0xFDF5, 0xFE09, 0xFE1B, 0xFE2C, 0xFE3D, 0xFE4C, 0xFE5A, 0xFE67,  // 80
	0xFE73, 0xFE7F, 0xFE8A, 0xFE95, 0xFE9F, 0xFEA8, 0xFEB1, 0xFEBA, 0xFEC2, 0xFEC9,  // 90
	0xFED1, 0xFED8, 0xFEDE, 0xFEE5, 0xFEEB, 0xFEF1, 0xFEF7, 0xFEFC, 0xFF01, 0xFF06,  // 100
	0xFF0B, 0xFF0D, 0xFF0F, 0xFF11, 0xFF13, 0xFF15, 0xFF16, 0xFF18, 0xFF1A, 0xFF1C,  // 110
	0xFF1D, 0xFF1F, 0xFF21, 0xFF22, 0xFF24, 0xFF25, 0xFF27, 0xFF29, 0xFF2A, 0xFF2B // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1800;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1600;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb16[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF53B, 0xF742, 0xF8A6, 0xF9A8, 0xFA6C, 0xFB07, 0xFB83, 0xFBEA, 0xFC40,  // 60
	0xFC88, 0xFCC7, 0xFCFE, 0xFD2E, 0xFD58, 0xFD7E, 0xFDA0, 0xFDBE, 0xFDDA, 0xFDF3,  // 70
	0xFE0A, 0xFE1F, 0xFE33, 0xFE45, 0xFE55, 0xFE65, 0xFE73, 0xFE81, 0xFE8E, 0xFE99,  // 80
	0xFEA4, 0xFEAF, 0xFEB9, 0xFEC2, 0xFECB, 0xFED3, 0xFEDB, 0xFEE3, 0xFEEA, 0xFEF1,  // 90
	0xFEF8, 0xFEFE, 0xFF04, 0xFF0A, 0xFF0F, 0xFF14, 0xFF19, 0xFF1E, 0xFF23, 0xFF27,  // 100
	0xFF2B, 0xFF2D, 0xFF2E, 0xFF30, 0xFF31, 0xFF33, 0xFF34, 0xFF35, 0xFF37, 0xFF38,  // 110
	0xFF39, 0xFF3B, 0xFF3C, 0xFF3D, 0xFF3E, 0xFF40, 0xFF41, 0xFF42, 0xFF43, 0xFF44 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2000;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1800;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb17[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF58E, 0xF7AE, 0xF916, 0xFA17, 0xFAD7, 0xFB6C, 0xFBE3, 0xFC45, 0xFC96,  // 60
	0xFCDA, 0xFD15, 0xFD48, 0xFD74, 0xFD9B, 0xFDBE, 0xFDDE, 0xFDFA, 0xFE13, 0xFE2A,  // 70
	0xFE3F, 0xFE52, 0xFE64, 0xFE74, 0xFE83, 0xFE92, 0xFE9F, 0xFEAB, 0xFEB6, 0xFEC1,  // 80
	0xFECB, 0xFED5, 0xFEDD, 0xFEE6, 0xFEEE, 0xFEF5, 0xFEFD, 0xFF03, 0xFF0A, 0xFF10,  // 90
	0xFF16, 0xFF1C, 0xFF21, 0xFF26, 0xFF2B, 0xFF30, 0xFF34, 0xFF38, 0xFF3D, 0xFF41,  // 100
	0xFF44, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4F,  // 110
	0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2200;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2000;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb18[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF5DC, 0xF80F, 0xF97A, 0xFA78, 0xFB33, 0xFBC3, 0xFC35, 0xFC91, 0xFCDE,  // 60
	0xFD1E, 0xFD56, 0xFD85, 0xFDAE, 0xFDD3, 0xFDF3, 0xFE10, 0xFE2A, 0xFE41, 0xFE57,  // 70
	0xFE6A, 0xFE7C, 0xFE8C, 0xFE9B, 0xFEA9, 0xFEB6, 0xFEC2, 0xFECD, 0xFED7, 0xFEE1,  // 80
	0xFEEA, 0xFEF3, 0xFEFB, 0xFF03, 0xFF0A, 0xFF11, 0xFF17, 0xFF1D, 0xFF23, 0xFF29,  // 90
	0xFF2E, 0xFF33, 0xFF38, 0xFF3D, 0xFF41, 0xFF46, 0xFF4A, 0xFF4E, 0xFF51, 0xFF55,  // 100
	0xFF59, 0xFF59, 0xFF5A, 0xFF5B, 0xFF5C, 0xFF5D, 0xFF5E, 0xFF5F, 0xFF60, 0xFF61,  // 110
	0xFF61, 0xFF62, 0xFF63, 0xFF64, 0xFF65, 0xFF66, 0xFF66, 0xFF67, 0xFF68, 0xFF69 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2400;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2200;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb19[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF625, 0xF868, 0xF9D4, 0xFACD, 0xFB83, 0xFC0E, 0xFC7B, 0xFCD3, 0xFD1B,  // 60
	0xFD58, 0xFD8C, 0xFDB8, 0xFDDF, 0xFE01, 0xFE1F, 0xFE3A, 0xFE52, 0xFE68, 0xFE7C,  // 70
	0xFE8E, 0xFE9E, 0xFEAD, 0xFEBB, 0xFEC8, 0xFED3, 0xFEDE, 0xFEE9, 0xFEF2, 0xFEFB,  // 80
	0xFF04, 0xFF0C, 0xFF13, 0xFF1A, 0xFF21, 0xFF27, 0xFF2D, 0xFF33, 0xFF38, 0xFF3D,  // 90
	0xFF42, 0xFF47, 0xFF4B, 0xFF50, 0xFF54, 0xFF58, 0xFF5B, 0xFF5F, 0xFF62, 0xFF66,  // 100
	0xFF69, 0xFF6A, 0xFF6A, 0xFF6B, 0xFF6C, 0xFF6D, 0xFF6D, 0xFF6E, 0xFF6F, 0xFF70,  // 110
	0xFF70, 0xFF71, 0xFF72, 0xFF72, 0xFF73, 0xFF74, 0xFF74, 0xFF75, 0xFF76, 0xFF76 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2600;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2400;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb20[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF66B, 0xF8B9, 0xFA24, 0xFB19, 0xFBCA, 0xFC4F, 0xFCB7, 0xFD0B, 0xFD50,  // 60
	0xFD8A, 0xFDBA, 0xFDE4, 0xFE09, 0xFE29, 0xFE45, 0xFE5E, 0xFE74, 0xFE89, 0xFE9B,  // 70
	0xFEAC, 0xFEBB, 0xFEC9, 0xFED6, 0xFEE1, 0xFEED, 0xFEF7, 0xFF00, 0xFF09, 0xFF11,  // 80
	0xFF19, 0xFF21, 0xFF27, 0xFF2E, 0xFF34, 0xFF3A, 0xFF3F, 0xFF45, 0xFF4A, 0xFF4E,  // 90
	0xFF53, 0xFF57, 0xFF5B, 0xFF5F, 0xFF63, 0xFF67, 0xFF6A, 0xFF6D, 0xFF71, 0xFF74,  // 100
	0xFF76, 0xFF77, 0xFF78, 0xFF78, 0xFF79, 0xFF7A, 0xFF7A, 0xFF7B, 0xFF7C, 0xFF7C,  // 110
	0xFF7D, 0xFF7D, 0xFF7E, 0xFF7F, 0xFF7F, 0xFF80, 0xFF80, 0xFF81, 0xFF81, 0xFF82 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2800;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2600;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb21[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF6AC, 0xF905, 0xFA6C, 0xFB5C, 0xFC08, 0xFC88, 0xFCEC, 0xFD3D, 0xFD7E,  // 60
	0xFDB4, 0xFDE3, 0xFE0A, 0xFE2C, 0xFE4B, 0xFE65, 0xFE7C, 0xFE92, 0xFEA4, 0xFEB6,  // 70
	0xFEC5, 0xFED3, 0xFEE0, 0xFEED, 0xFEF8, 0xFF02, 0xFF0B, 0xFF14, 0xFF1C, 0xFF24,  // 80
	0xFF2B, 0xFF32, 0xFF39, 0xFF3F, 0xFF44, 0xFF4A, 0xFF4F, 0xFF54, 0xFF59, 0xFF5D,  // 90
	0xFF61, 0xFF65, 0xFF69, 0xFF6C, 0xFF70, 0xFF73, 0xFF76, 0xFF7A, 0xFF7C, 0xFF7F,  // 100
	0xFF82, 0xFF83, 0xFF83, 0xFF84, 0xFF84, 0xFF85, 0xFF85, 0xFF86, 0xFF86, 0xFF87,  // 110
	0xFF87, 0xFF88, 0xFF88, 0xFF89, 0xFF89, 0xFF8A, 0xFF8A, 0xFF8B, 0xFF8B, 0xFF8C // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3000;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2800;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb22[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF6EB, 0xF94A, 0xFAAE, 0xFB99, 0xFC40, 0xFCBB, 0xFD1B, 0xFD68, 0xFDA6,  // 60
	0xFDDA, 0xFE06, 0xFE2B, 0xFE4C, 0xFE68, 0xFE81, 0xFE97, 0xFEAB, 0xFEBD, 0xFECD,  // 70
	0xFEDB, 0xFEE9, 0xFEF5, 0xFF00, 0xFF0B, 0xFF14, 0xFF1D, 0xFF25, 0xFF2D, 0xFF34,  // 80
	0xFF3B, 0xFF42, 0xFF48, 0xFF4D, 0xFF53, 0xFF58, 0xFF5C, 0xFF61, 0xFF65, 0xFF69,  // 90
	0xFF6D, 0xFF71, 0xFF74, 0xFF78, 0xFF7B, 0xFF7E, 0xFF81, 0xFF84, 0xFF87, 0xFF89,  // 100
	0xFF8C, 0xFF8C, 0xFF8D, 0xFF8D, 0xFF8E, 0xFF8E, 0xFF8F, 0xFF8F, 0xFF90, 0xFF90,  // 110
	0xFF91, 0xFF91, 0xFF91, 0xFF92, 0xFF92, 0xFF93, 0xFF93, 0xFF94, 0xFF94, 0xFF94 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3200;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 3000;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb23[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF726, 0xF98A, 0xFAEB, 0xFBD0, 0xFC71, 0xFCE9, 0xFD45, 0xFD8E, 0xFDCA,  // 60
	0xFDFB, 0xFE25, 0xFE48, 0xFE67, 0xFE82, 0xFE99, 0xFEAE, 0xFEC1, 0xFED2, 0xFEE1,  // 70
	0xFEEF, 0xFEFB, 0xFF07, 0xFF11, 0xFF1B, 0xFF24, 0xFF2D, 0xFF34, 0xFF3C, 0xFF42,  // 80
	0xFF49, 0xFF4F, 0xFF54, 0xFF5A, 0xFF5F, 0xFF63, 0xFF68, 0xFF6C, 0xFF70, 0xFF74,  // 90
	0xFF78, 0xFF7B, 0xFF7F, 0xFF82, 0xFF85, 0xFF88, 0xFF8A, 0xFF8D, 0xFF90, 0xFF92,  // 100
	0xFF94, 0xFF95, 0xFF95, 0xFF96, 0xFF96, 0xFF97, 0xFF97, 0xFF97, 0xFF98, 0xFF98,  // 110
	0xFF99, 0xFF99, 0xFF99, 0xFF9A, 0xFF9A, 0xFF9A, 0xFF9B, 0xFF9B, 0xFF9C, 0xFF9C // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 3400;
起始折点     = 50;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 3200;
周脉冲数     = 2000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb24[]={
	0xE3EE, 0xE47A, 0xE500, 0xE585, 0xE602, 0xE67A, 0xE6F1, 0xE761, 0xE7CD, 0xE838,  // 10
	0xE89C, 0xE8FE, 0xE95F, 0xE9BA, 0xEA13, 0xEA6B, 0xEABE, 0xEB0F, 0xEB5F, 0xEBAB,  // 20
	0xEBF5, 0xEC3F, 0xEC84, 0xECC8, 0xED0C, 0xED4C, 0xED8B, 0xEDCA, 0xEE05, 0xEE3F,  // 30
	0xEE79, 0xEEB0, 0xEEE6, 0xEF1C, 0xEF4F, 0xEF81, 0xEFB3, 0xEFE3, 0xF011, 0xF040,  // 40
	0xF06C, 0xF098, 0xF0C4, 0xF0EE, 0xF116, 0xF13F, 0xF166, 0xF18D, 0xF1B3, 0xF1D8,  // 50
	0xF1FC, 0xF75E, 0xF9C5, 0xFB22, 0xFC02, 0xFC9E, 0xFD12, 0xFD6A, 0xFDB0, 0xFDE9,  // 60
	0xFE18, 0xFE40, 0xFE62, 0xFE7F, 0xFE99, 0xFEAF, 0xFEC3, 0xFED5, 0xFEE4, 0xFEF3,  // 70
	0xFF00, 0xFF0C, 0xFF17, 0xFF21, 0xFF2A, 0xFF32, 0xFF3A, 0xFF42, 0xFF48, 0xFF4F,  // 80
	0xFF55, 0xFF5A, 0xFF60, 0xFF65, 0xFF69, 0xFF6E, 0xFF72, 0xFF76, 0xFF7A, 0xFF7E,  // 90
	0xFF81, 0xFF84, 0xFF87, 0xFF8A, 0xFF8D, 0xFF90, 0xFF93, 0xFF95, 0xFF97, 0xFF9A,  // 100
	0xFF9C, 0xFF9C, 0xFF9D, 0xFF9D, 0xFF9D, 0xFF9E, 0xFF9E, 0xFF9F, 0xFF9F, 0xFF9F,  // 110
	0xFFA0, 0xFFA0, 0xFFA0, 0xFFA1, 0xFFA1, 0xFFA1, 0xFFA2, 0xFFA2, 0xFFA2, 0xFFA3 // 120
	
};


//------------xxxxxxxxxxxxxxxxxxxxxxxxxx快速启动停止---
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1200;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1000;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb25[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xE6C4, 0xE918, 0xEB05, 0xECA8, 0xEE0C, 0xEF43, 0xF050, 0xF13F, 0xF213,  // 30
	0xF2D1, 0xF37A, 0xF415, 0xF4A1, 0xF521, 0xF595, 0xF601, 0xF664, 0xF6C0, 0xF716,  // 40
	0xF765, 0xF7AF, 0xF7F5, 0xF835, 0xF873, 0xF8AC, 0xF8E2, 0xF915, 0xF946, 0xF973,  // 50
	0xF99F, 0xF9C8, 0xF9EF, 0xFA15, 0xFA38, 0xFA5A, 0xFA7B, 0xFA9A, 0xFAB8, 0xFAD4,  // 60
	0xFAEF, 0xFB0A, 0xFB23, 0xFB3B, 0xFB52, 0xFB69, 0xFB7F, 0xFB93, 0xFBA8, 0xFBBB,  // 70
	0xFBCE, 0xFBE0, 0xFBF1, 0xFC02, 0xFC13, 0xFC23, 0xFC32, 0xFC41, 0xFC50, 0xFC5E,  // 80
	0xFC6B, 0xFC79, 0xFC86, 0xFC92, 0xFC9E, 0xFCAA, 0xFCB6, 0xFCC1, 0xFCCC, 0xFCD7,  // 90
	0xFCE1, 0xFCEB, 0xFCF5, 0xFCFF, 0xFD08, 0xFD12, 0xFD1B, 0xFD23, 0xFD2C, 0xFD34,  // 100
	0xFD3D, 0xFD44, 0xFD4B, 0xFD53, 0xFD5A, 0xFD61, 0xFD67, 0xFD6E, 0xFD74, 0xFD7B,  // 110
	0xFD81, 0xFD87, 0xFD8D, 0xFD93, 0xFD99, 0xFD9F, 0xFDA4, 0xFDAA, 0xFDAF, 0xFDB4 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1400;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1200;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb26[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xE753, 0xE9FD, 0xEC23, 0xEDE7, 0xEF61, 0xF0A4, 0xF1B8, 0xF2A8, 0xF37A,  // 30
	0xF435, 0xF4DA, 0xF570, 0xF5F6, 0xF66F, 0xF6DD, 0xF742, 0xF79F, 0xF7F5, 0xF843,  // 40
	0xF88C, 0xF8D0, 0xF910, 0xF94B, 0xF982, 0xF9B6, 0xF9E7, 0xFA15, 0xFA40, 0xFA69,  // 50
	0xFA90, 0xFAB4, 0xFAD7, 0xFAF8, 0xFB18, 0xFB36, 0xFB52, 0xFB6E, 0xFB88, 0xFBA1,  // 60
	0xFBB9, 0xFBD0, 0xFBE6, 0xFBFB, 0xFC0F, 0xFC23, 0xFC36, 0xFC48, 0xFC59, 0xFC6A,  // 70
	0xFC7A, 0xFC8A, 0xFC99, 0xFCA8, 0xFCB6, 0xFCC4, 0xFCD1, 0xFCDE, 0xFCEA, 0xFCF6,  // 80
	0xFD02, 0xFD0E, 0xFD19, 0xFD23, 0xFD2E, 0xFD38, 0xFD42, 0xFD4B, 0xFD55, 0xFD5E,  // 90
	0xFD67, 0xFD6F, 0xFD78, 0xFD80, 0xFD88, 0xFD90, 0xFD98, 0xFD9F, 0xFDA6, 0xFDAE,  // 100
	0xFDB4, 0xFDBA, 0xFDBF, 0xFDC4, 0xFDC9, 0xFDCE, 0xFDD3, 0xFDD7, 0xFDDC, 0xFDE0,  // 110
	0xFDE5, 0xFDE9, 0xFDEE, 0xFDF2, 0xFDF6, 0xFDFA, 0xFDFE, 0xFE02, 0xFE06, 0xFE0A // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1600;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1400;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb27[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xE7D9, 0xEAD2, 0xED24, 0xEF01, 0xF088, 0xF1CF, 0xF2E4, 0xF3D2, 0xF4A1,  // 30
	0xF556, 0xF5F6, 0xF684, 0xF703, 0xF776, 0xF7DE, 0xF83C, 0xF893, 0xF8E2, 0xF92B,  // 40
	0xF96E, 0xF9AD, 0xF9E7, 0xFA1D, 0xFA4F, 0xFA7E, 0xFAAA, 0xFAD4, 0xFAFB, 0xFB20,  // 50
	0xFB43, 0xFB64, 0xFB83, 0xFBA1, 0xFBBD, 0xFBD8, 0xFBF1, 0xFC0A, 0xFC21, 0xFC37,  // 60
	0xFC4C, 0xFC61, 0xFC74, 0xFC87, 0xFC99, 0xFCAA, 0xFCBB, 0xFCCB, 0xFCDA, 0xFCE9,  // 70
	0xFCF7, 0xFD05, 0xFD13, 0xFD1F, 0xFD2C, 0xFD38, 0xFD44, 0xFD4F, 0xFD5A, 0xFD64,  // 80
	0xFD6F, 0xFD79, 0xFD82, 0xFD8C, 0xFD95, 0xFD9E, 0xFDA6, 0xFDAF, 0xFDB7, 0xFDBF,  // 90
	0xFDC7, 0xFDCE, 0xFDD6, 0xFDDD, 0xFDE4, 0xFDEB, 0xFDF1, 0xFDF8, 0xFDFE, 0xFE04,  // 100
	0xFE0A, 0xFE0E, 0xFE12, 0xFE16, 0xFE19, 0xFE1D, 0xFE20, 0xFE24, 0xFE27, 0xFE2B,  // 110
	0xFE2E, 0xFE31, 0xFE35, 0xFE38, 0xFE3B, 0xFE3E, 0xFE41, 0xFE45, 0xFE48, 0xFE4B // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1800;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1600;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb28[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xE85D, 0xEB99, 0xEE0C, 0xEFFB, 0xF188, 0xF2D1, 0xF3E3, 0xF4CD, 0xF595,  // 30
	0xF644, 0xF6DD, 0xF765, 0xF7DE, 0xF84A, 0xF8AC, 0xF905, 0xF955, 0xF99F, 0xF9E2,  // 40
	0xFA21, 0xFA5A, 0xFA90, 0xFAC1, 0xFAEF, 0xFB1B, 0xFB43, 0xFB69, 0xFB8D, 0xFBAE,  // 50
	0xFBCE, 0xFBEC, 0xFC08, 0xFC23, 0xFC3C, 0xFC54, 0xFC6B, 0xFC81, 0xFC96, 0xFCAA,  // 60
	0xFCBD, 0xFCD0, 0xFCE1, 0xFCF2, 0xFD02, 0xFD12, 0xFD20, 0xFD2F, 0xFD3D, 0xFD4A,  // 70
	0xFD57, 0xFD63, 0xFD6F, 0xFD7A, 0xFD85, 0xFD90, 0xFD9A, 0xFDA4, 0xFDAE, 0xFDB8,  // 80
	0xFDC1, 0xFDCA, 0xFDD2, 0xFDDB, 0xFDE3, 0xFDEB, 0xFDF2, 0xFDFA, 0xFE01, 0xFE08,  // 90
	0xFE0F, 0xFE15, 0xFE1C, 0xFE22, 0xFE28, 0xFE2E, 0xFE34, 0xFE3A, 0xFE40, 0xFE45,  // 100
	0xFE4B, 0xFE4D, 0xFE50, 0xFE53, 0xFE56, 0xFE59, 0xFE5C, 0xFE5E, 0xFE61, 0xFE64,  // 110
	0xFE66, 0xFE69, 0xFE6B, 0xFE6E, 0xFE70, 0xFE73, 0xFE75, 0xFE78, 0xFE7A, 0xFE7C // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2000;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 1800;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb29[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xE8DB, 0xEC50, 0xEEDF, 0xF0D8, 0xF269, 0xF3B0, 0xF4BE, 0xF5A2, 0xF664,  // 30
	0xF70C, 0xF79F, 0xF820, 0xF893, 0xF8F9, 0xF955, 0xF9A8, 0xF9F3, 0xFA38, 0xFA77,  // 40
	0xFAB1, 0xFAE6, 0xFB18, 0xFB46, 0xFB70, 0xFB98, 0xFBBD, 0xFBE0, 0xFC00, 0xFC1F,  // 50
	0xFC3C, 0xFC58, 0xFC71, 0xFC8A, 0xFCA1, 0xFCB7, 0xFCCC, 0xFCE0, 0xFCF3, 0xFD05,  // 60
	0xFD17, 0xFD27, 0xFD37, 0xFD46, 0xFD55, 0xFD63, 0xFD70, 0xFD7D, 0xFD8A, 0xFD96,  // 70
	0xFDA1, 0xFDAC, 0xFDB7, 0xFDC1, 0xFDCB, 0xFDD5, 0xFDDE, 0xFDE7, 0xFDF0, 0xFDF9,  // 80
	0xFE01, 0xFE09, 0xFE11, 0xFE18, 0xFE1F, 0xFE26, 0xFE2D, 0xFE34, 0xFE3A, 0xFE41,  // 90
	0xFE47, 0xFE4D, 0xFE53, 0xFE58, 0xFE5E, 0xFE63, 0xFE69, 0xFE6E, 0xFE73, 0xFE78,  // 100
	0xFE7C, 0xFE7F, 0xFE81, 0xFE83, 0xFE86, 0xFE88, 0xFE8A, 0xFE8C, 0xFE8E, 0xFE91,  // 110
	0xFE93, 0xFE95, 0xFE97, 0xFE99, 0xFE9B, 0xFE9D, 0xFE9F, 0xFEA1, 0xFEA3, 0xFEA4 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2200;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2000;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb30[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xE951, 0xECFA, 0xEFA0, 0xF1A0, 0xF331, 0xF474, 0xF57C, 0xF65A, 0xF716,  // 30
	0xF7B7, 0xF843, 0xF8BE, 0xF92B, 0xF98C, 0xF9E2, 0xFA30, 0xFA77, 0xFAB8, 0xFAF2,  // 40
	0xFB28, 0xFB5A, 0xFB88, 0xFBB2, 0xFBDA, 0xFBFF, 0xFC21, 0xFC41, 0xFC5F, 0xFC7C,  // 50
	0xFC96, 0xFCAF, 0xFCC7, 0xFCDE, 0xFCF3, 0xFD07, 0xFD1B, 0xFD2D, 0xFD3E, 0xFD4F,  // 60
	0xFD5F, 0xFD6E, 0xFD7C, 0xFD8A, 0xFD98, 0xFDA4, 0xFDB1, 0xFDBD, 0xFDC8, 0xFDD3,  // 70
	0xFDDD, 0xFDE7, 0xFDF1, 0xFDFB, 0xFE04, 0xFE0C, 0xFE15, 0xFE1D, 0xFE25, 0xFE2D,  // 80
	0xFE34, 0xFE3C, 0xFE43, 0xFE49, 0xFE50, 0xFE56, 0xFE5D, 0xFE63, 0xFE69, 0xFE6E,  // 90
	0xFE74, 0xFE79, 0xFE7F, 0xFE84, 0xFE89, 0xFE8E, 0xFE93, 0xFE97, 0xFE9C, 0xFEA0,  // 100
	0xFEA4, 0xFEA6, 0xFEA8, 0xFEAA, 0xFEAC, 0xFEAE, 0xFEB0, 0xFEB1, 0xFEB3, 0xFEB5,  // 110
	0xFEB7, 0xFEB8, 0xFEBA, 0xFEBC, 0xFEBD, 0xFEBF, 0xFEC0, 0xFEC2, 0xFEC4, 0xFEC5 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2400;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2200;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb31[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xE9C5, 0xED9C, 0xF050, 0xF255, 0xF3E3, 0xF521, 0xF623, 0xF6FA, 0xF7AF,  // 30
	0xF84A, 0xF8D0, 0xF946, 0xF9AD, 0xFA08, 0xFA5A, 0xFAA4, 0xFAE6, 0xFB23, 0xFB5A,  // 40
	0xFB8D, 0xFBBB, 0xFBE6, 0xFC0D, 0xFC32, 0xFC54, 0xFC74, 0xFC92, 0xFCAE, 0xFCC8,  // 50
	0xFCE1, 0xFCF9, 0xFD0F, 0xFD23, 0xFD37, 0xFD4A, 0xFD5C, 0xFD6C, 0xFD7C, 0xFD8C,  // 60
	0xFD9A, 0xFDA8, 0xFDB6, 0xFDC3, 0xFDCF, 0xFDDB, 0xFDE6, 0xFDF1, 0xFDFB, 0xFE05,  // 70
	0xFE0F, 0xFE18, 0xFE21, 0xFE2A, 0xFE32, 0xFE3A, 0xFE42, 0xFE49, 0xFE51, 0xFE58,  // 80
	0xFE5F, 0xFE65, 0xFE6C, 0xFE72, 0xFE78, 0xFE7E, 0xFE84, 0xFE89, 0xFE8F, 0xFE94,  // 90
	0xFE99, 0xFE9E, 0xFEA3, 0xFEA7, 0xFEAC, 0xFEB0, 0xFEB5, 0xFEB9, 0xFEBD, 0xFEC1,  // 100
	0xFEC5, 0xFEC7, 0xFEC8, 0xFECA, 0xFECB, 0xFECD, 0xFECE, 0xFED0, 0xFED1, 0xFED3,  // 110
	0xFED4, 0xFED6, 0xFED7, 0xFED8, 0xFEDA, 0xFEDB, 0xFEDD, 0xFEDE, 0xFEDF, 0xFEE0 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2600;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2400;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb32[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xEA35, 0xEE31, 0xF0F3, 0xF2F7, 0xF482, 0xF5BA, 0xF6B7, 0xF787, 0xF835,  // 30
	0xF8CA, 0xF94B, 0xF9BB, 0xFA1D, 0xFA74, 0xFAC1, 0xFB07, 0xFB46, 0xFB7F, 0xFBB2,  // 40
	0xFBE2, 0xFC0D, 0xFC36, 0xFC5B, 0xFC7D, 0xFC9D, 0xFCBB, 0xFCD7, 0xFCF1, 0xFD09,  // 50
	0xFD20, 0xFD36, 0xFD4B, 0xFD5E, 0xFD70, 0xFD82, 0xFD92, 0xFDA2, 0xFDB1, 0xFDBF,  // 60
	0xFDCC, 0xFDD9, 0xFDE6, 0xFDF2, 0xFDFD, 0xFE08, 0xFE12, 0xFE1C, 0xFE26, 0xFE2F,  // 70
	0xFE38, 0xFE41, 0xFE49, 0xFE51, 0xFE59, 0xFE60, 0xFE67, 0xFE6E, 0xFE75, 0xFE7C,  // 80
	0xFE82, 0xFE88, 0xFE8E, 0xFE94, 0xFE99, 0xFE9F, 0xFEA4, 0xFEA9, 0xFEAE, 0xFEB3,  // 90
	0xFEB8, 0xFEBC, 0xFEC1, 0xFEC5, 0xFEC9, 0xFECD, 0xFED1, 0xFED5, 0xFED9, 0xFEDD,  // 100
	0xFEE0, 0xFEE2, 0xFEE3, 0xFEE4, 0xFEE6, 0xFEE7, 0xFEE8, 0xFEE9, 0xFEEB, 0xFEEC,  // 110
	0xFEED, 0xFEEE, 0xFEEF, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4, 0xFEF5, 0xFEF6, 0xFEF8 // 120
	
};
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 2800;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 2600;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const waitTb33[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xEA9E, 0xEEBD, 0xF188, 0xF38C, 0xF513, 0xF644, 0xF739, 0xF803, 0xF8AC,  // 30
	0xF93B, 0xF9B6, 0xFA21, 0xFA7E, 0xFAD1, 0xFB1B, 0xFB5C, 0xFB98, 0xFBCE, 0xFBFF,  // 40
	0xFC2B, 0xFC54, 0xFC7A, 0xFC9D, 0xFCBD, 0xFCDB, 0xFCF7, 0xFD12, 0xFD2A, 0xFD41,  // 50
	0xFD57, 0xFD6B, 0xFD7E, 0xFD90, 0xFDA1, 0xFDB1, 0xFDC1, 0xFDCF, 0xFDDD, 0xFDEB,  // 60
	0xFDF7, 0xFE03, 0xFE0F, 0xFE1A, 0xFE24, 0xFE2E, 0xFE38, 0xFE42, 0xFE4B, 0xFE53,  // 70
	0xFE5B, 0xFE63, 0xFE6B, 0xFE73, 0xFE7A, 0xFE81, 0xFE87, 0xFE8E, 0xFE94, 0xFE9A,  // 80
	0xFEA0, 0xFEA6, 0xFEAB, 0xFEB0, 0xFEB6, 0xFEBB, 0xFEC0, 0xFEC4, 0xFEC9, 0xFECD,  // 90
	0xFED2, 0xFED6, 0xFEDA, 0xFEDE, 0xFEE2, 0xFEE6, 0xFEEA, 0xFEED, 0xFEF1, 0xFEF4,  // 100
	0xFEF8, 0xFEF9, 0xFEFA, 0xFEFB, 0xFEFC, 0xFEFD, 0xFEFE, 0xFEFF, 0xFF00, 0xFF01,  // 110
	0xFF02, 0xFF03, 0xFF04, 0xFF05, 0xFF06, 0xFF07, 0xFF08, 0xFF09, 0xFF0A, 0xFF0B // 120
	
};



/////////////////////////////////////////////////////////////////////---------------------------------------------------
// 晶振频率=96MHz; 预分频率=4
// 参数设定值: V0 = 20; 折点1= 100; 折点2 = 1750 极限转速 = 2000 rpm
//         Point0= 0;第一折点= 12;第二折点= 100; 终点步数= 120
// 电机转动一周对应脉冲数=1200; 编程响应(CTn rewrite)补偿步数 = 8
/////////////////////////////////////////////////////////////////////////
unsigned int const waitTb88[]={
    0xABA0, 0xC8F9, 0xD72D, 0xDF96, 0xE520, 0xE90E, 0xEBFF, 0xEE44, 0xF014, 0xF18F,  // 10
	0xF2C9, 0xF3D3, 0xF4B6, 0xF57B, 0xF627, 0xF6BF, 0xF745, 0xF7BD, 0xF829, 0xF88B,  // 20
	0xF8E3, 0xF934, 0xF97E, 0xF9C2, 0xFA01, 0xFA3B, 0xFA71, 0xFAA3, 0xFAD1, 0xFAFD,  // 30
	0xFB26, 0xFB4C, 0xFB70, 0xFB92, 0xFBB2, 0xFBD0, 0xFBED, 0xFC08, 0xFC22, 0xFC3A,  // 40
	0xFC52, 0xFC68, 0xFC7D, 0xFC91, 0xFCA5, 0xFCB7, 0xFCC9, 0xFCDA, 0xFCEA, 0xFCFA,  // 50
	0xFD09, 0xFD17, 0xFD25, 0xFD33, 0xFD40, 0xFD4C, 0xFD58, 0xFD64, 0xFD6F, 0xFD7A,  // 60
	0xFD84, 0xFD8E, 0xFD98, 0xFDA1, 0xFDAB, 0xFDB4, 0xFDBC, 0xFDC5, 0xFDCD, 0xFDD5,  // 70
	0xFDDC, 0xFDE4, 0xFDEB, 0xFDF2, 0xFDF9, 0xFE00, 0xFE06, 0xFE0D, 0xFE13, 0xFE19,  // 80
	0xFE1F, 0xFE24, 0xFE2A, 0xFE30, 0xFE35, 0xFE3A, 0xFE3F, 0xFE44, 0xFE49, 0xFE4E,  // 90
	0xFE52, 0xFE57, 0xFE5B, 0xFE60, 0xFE64, 0xFE68, 0xFE6C, 0xFE70, 0xFE74, 0xFE78,  // 100
	0xFE7C, 0xFE7F, 0xFE83, 0xFE87, 0xFE8A, 0xFE8D, 0xFE91, 0xFE94, 0xFE97, 0xFE9A,  // 110
	0xFE9D, 0xFEA1, 0xFEA4, 0xFEA6, 0xFEA9, 0xFEAC, 0xFEAF, 0xFEB2, 0xFEB4, 0xFEB7 // 120
};
//start  run
/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 1200;
起始折点     = 20;
折点转速m    = 200;
高速折点     = 100;
折点转速f    = 1000;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const JogTable[]={
	0xC7C7, 0xCF1E, 0xD4C4, 0xD93F, 0xDCE2, 0xDFE6, 0xE270, 0xE49B, 0xE67A, 0xE81C,  // 10
	0xE98C, 0xEAD2, 0xEBF5, 0xECFA, 0xEDE7, 0xEEBD, 0xEF81, 0xF034, 0xF0D8, 0xF170,  // 20
	0xF1FC, 0xF2A8, 0xF344, 0xF3D2, 0xF454, 0xF4CD, 0xF53B, 0xF5A2, 0xF601, 0xF65A,  // 30
	0xF6AC, 0xF6FA, 0xF742, 0xF787, 0xF7C7, 0xF803, 0xF83C, 0xF873, 0xF8A6, 0xF8D6,  // 40
	0xF905, 0xF930, 0xF95A, 0xF982, 0xF9A8, 0xF9CC, 0xF9EF, 0xFA11, 0xFA30, 0xFA4F,  // 50
	0xFA6C, 0xFA89, 0xFAA4, 0xFABE, 0xFAD7, 0xFAEF, 0xFB07, 0xFB1D, 0xFB33, 0xFB48,  // 60
	0xFB5C, 0xFB70, 0xFB83, 0xFB96, 0xFBA8, 0xFBB9, 0xFBCA, 0xFBDA, 0xFBEA, 0xFBF9,  // 70
	0xFC08, 0xFC16, 0xFC24, 0xFC32, 0xFC40, 0xFC4C, 0xFC59, 0xFC65, 0xFC71, 0xFC7D,  // 80
	0xFC88, 0xFC94, 0xFC9E, 0xFCA9, 0xFCB3, 0xFCBD, 0xFCC7, 0xFCD1, 0xFCDA, 0xFCE3,  // 90
	0xFCEC, 0xFCF5, 0xFCFE, 0xFD06, 0xFD0F, 0xFD17, 0xFD1E, 0xFD26, 0xFD2E, 0xFD35,  // 100
	0xFD3D, 0xFD44, 0xFD4B, 0xFD53, 0xFD5A, 0xFD61, 0xFD67, 0xFD6E, 0xFD74, 0xFD7B,  // 110
	0xFD81, 0xFD87, 0xFD8D, 0xFD93, 0xFD99, 0xFD9F, 0xFDA4, 0xFDAA, 0xFDAF, 0xFDB4 // 120
	
};

/*============================================================================
步进伺服电机曲线计算参数表，请保留这部分完整不要作任何修改，备查. 
  Ver = 2.0    www.xiao-qi.com     晓奇工作室应用软件组
晶震频率     = 12.000000;
预分频率     = 1;
起步速度     = 50;
极限终点     = 119;
极限转速     = 500;
起始折点     = 20;
折点转速m    = 100;
高速折点     = 100;
折点转速f    = 480;
周脉冲数     = 1000;
中断响应编程补偿 = 12;
T梯形曲线生成类型
 ============================================================================*/
unsigned int const Table500[]={
	0xC7C7, 0xCA7A, 0xCCEE, 0xCF1E, 0xD12C, 0xD310, 0xD4C4, 0xD662, 0xD7E2, 0xD93F,  // 10
	0xDA8C, 0xDBC5, 0xDCE2, 0xDDF5, 0xDEF8, 0xDFE6, 0xE0CC, 0xE1A6, 0xE270, 0xE334,  // 20
	0xE3EE, 0xE534, 0xE65D, 0xE76E, 0xE869, 0xE951, 0xEA2A, 0xEAF2, 0xEBAB, 0xEC58,  // 30
	0xECFA, 0xED93, 0xEE23, 0xEEA9, 0xEF28, 0xEFA0, 0xF011, 0xF07C, 0xF0E4, 0xF144,  // 40
	0xF1A0, 0xF1F8, 0xF24B, 0xF29B, 0xF2E8, 0xF331, 0xF377, 0xF3BA, 0xF3FA, 0xF438,  // 50
	0xF474, 0xF4AD, 0xF4E3, 0xF518, 0xF54B, 0xF57C, 0xF5AC, 0xF5DA, 0xF606, 0xF630,  // 60
	0xF65A, 0xF682, 0xF6A9, 0xF6CE, 0xF6F2, 0xF716, 0xF738, 0xF759, 0xF77A, 0xF799,  // 70
	0xF7B7, 0xF7D5, 0xF7F1, 0xF80D, 0xF829, 0xF843, 0xF85D, 0xF876, 0xF88F, 0xF8A7,  // 80
	0xF8BE, 0xF8D5, 0xF8EB, 0xF901, 0xF916, 0xF92B, 0xF93F, 0xF953, 0xF966, 0xF979,  // 90
	0xF98C, 0xF99E, 0xF9B0, 0xF9C1, 0xF9D2, 0xF9E2, 0xF9F3, 0xFA03, 0xFA12, 0xFA22,  // 100
	0xFA30, 0xFA34, 0xFA37, 0xFA3A, 0xFA3E, 0xFA41, 0xFA44, 0xFA47, 0xFA4A, 0xFA4E,  // 110
	0xFA51, 0xFA54, 0xFA57, 0xFA5A, 0xFA5D, 0xFA60, 0xFA63, 0xFA66, 0xFA69, 0xFA6C // 120
	
};


void Timer0IntrHandler(void)   //50US 定时中断
{
  unsigned long int i;
  Int32U temp,z_dif;
//user code start
  //WDFEED = 0xaa;
 // WDFEED = 0x55;
//user code end
  // clear interrupt
////  T0IR_bit.MR0INT = 1;
   
 ////*******************************************
   switch(MotorType)
	{
	case MOTOR_FREQ_5_SPD_RST:
	case MOTOR_FREQ_3_SPD:
	case MOTOR_FREQ_3_SPD_RST:
				if(OIN6_PIN)   //如果第一路光藕输入为高?
				{
					xa1=1;
				}
				else//if(!OIN6_PIN)   //如果第一路光藕输入为高?
				{
					xa1=0;
				}
				
				
				 if(OIN7_PIN)   //如果第一路光藕输入为高?
				{
					xb1=1;
				}
				else//if(!OIN7_PIN)   //如果第一路光藕输入为高?
				{
					xb1=0;
				}      
				
				 if(OIN8_PIN)   //如果第一路光藕输入为高?
				{
					xz=1;
					if(z_mode==1)
						z_mode=2;
				}
				else//if(!OIN8_PIN)   //如果第一路光藕输入为高?
				{   
					xz=0;
					if(z_mode==0)
						z_mode=1;
				}	
				  
			   
				  
				  
				
				
				if(OIN1_PIN)   //如果第一路光藕输入为高?
				{   
				   senor=1;
				   xsenor1=1;
				}
				else//if(!OIN1_PIN)   //如果第一路光藕输入为高?
				{
				   senor=0;
					xsenor1=1;
				   if(flagyunxing==1)
				   {
					  flagsenor=1;
				   }   
				}
				
				
				
				
				
					
			  
				
		   if(xa==0&&xb==0)  
		  { 
			if(xa1==1&&xb1==0)
			  { 
				 qianjin=0;
				  houtui=1;
				 muqiancn=muqiancn+maichongdangliang;  
				// CurrentSize=muqiancn/1000;
				// xxmuqiancn=xxmuqiancn+maichongdangliang;
				if(WorkStart_flag==1)
				Zpulse_cou--;
			  }
		  }
		  
		   if(xa==1&&xb==0)  
		  { 
			if(xa1==1&&xb1==1)
			  {  
				 qianjin=0;
				 houtui=1;
			   muqiancn=muqiancn+maichongdangliang;
			//   CurrentSize=muqiancn/1000;
			 // xxmuqiancn=xxmuqiancn+maichongdangliang;
			 if(WorkStart_flag==1)
				Zpulse_cou--;
			   }
		 }
		 
		  if(xa==1&&xb==1)  
		  { 
			if(xa1==0&&xb1==1)
			  {  
				  qianjin=0;
				  houtui=1;
				  muqiancn=muqiancn+maichongdangliang; 
			//	  CurrentSize=muqiancn/1000;
				//  xxmuqiancn=xxmuqiancn+maichongdangliang;
				if(WorkStart_flag==1)
				Zpulse_cou--;
			   }
		  }
		  
		   if(xa==0&&xb==1)
			{
			  if(xa1==0&&xb1==0)
				{ 
				  qianjin=0;
				  houtui=1;
				  muqiancn=muqiancn+maichongdangliang; 
			//	  CurrentSize=muqiancn/1000;
			//	  xxmuqiancn=xxmuqiancn+maichongdangliang;
				if(WorkStart_flag==1)
				Zpulse_cou--;
				}
			}
		  
		  
		   if(xa==0&&xb==0)
			 {
			  if(xa1==0&&xb1==1)
				{ 
				qianjin=1;
				  houtui=0; 
				 muqiancn=muqiancn-maichongdangliang;
			//	 CurrentSize=muqiancn/1000;
				// xxmuqiancn=xxmuqiancn-maichongdangliang;
				 Zpulse_cou++;
				}
			 }
			 
		  
			if(xa==0&&xb==1)
			 {
			 if(xa1==1&&xb1==1)
			   {  
				qianjin=1;
				  houtui=0;
				  muqiancn=muqiancn-maichongdangliang;  
			//	  CurrentSize=muqiancn/1000;
			//	  xxmuqiancn=xxmuqiancn-maichongdangliang;
				  Zpulse_cou++;
				}
			 }    
				
			if(xa==1&&xb==1)
			 {
			  if(xa1==1&&xb1==0)
				{ 
				  qianjin=1;
				  houtui=0;
				  muqiancn=muqiancn-maichongdangliang;
			//	  CurrentSize=muqiancn/1000;
				//  xxmuqiancn=xxmuqiancn-maichongdangliang;
				  Zpulse_cou++;
				}
			  }
			 
			  
			  if(xa==1&&xb==0)
		  {
			if(xa1==0&&xb1==0)
			  { 
			   qianjin=1;
			   houtui=0;
			   muqiancn=muqiancn-maichongdangliang; 
			 //  CurrentSize=muqiancn/1000;
			//   xxmuqiancn=xxmuqiancn-maichongdangliang;
			   Zpulse_cou++;
			  }
		  }  
			  
		   xa=xa1;
		   xb=xb1;  

	///-----------------------------------------------------------------------------------------Z---pule------------------------
				if(z_mode==2)
					{
					if((xa==0)&&(xb==0))
						{
						if(WorkStart_flag==1)
							{
							if(Z_Pulse_start_flag==0)
								{
								Z_Pulse_start_flag=1;
								Zpulse_cou=0xffff;
								}
							else
								{
								if(Zpulse_cou>Z_Pulse_before)
									z_dif=Zpulse_cou-Z_Pulse_before;
								else
									z_dif=Z_Pulse_before-Zpulse_cou;
								if((z_dif==Z_Pulse)||(z_dif==0))
									{
									Z_Pulse_err_flag=0;//	BellOUT_OFF;
									Z_code_err_time=0;
									}
								else
									{		//--------------编码器ab 出错
									Z_code_err_time++;
									if(Z_code_err_time>=2)
										{
										Z_code_err_time=0;
									//	Z_Pulse_err_flag=1;//BellOUT_ON;
										Z_code_error=z_dif;
										}
									}
								}
							Z_Pulse_before=Zpulse_cou;
							}
						z_mode=0;
						}
					}
		   
		 //---------------------------------------------------------------
		 CurrentSize=muqiancn/1000;
		if(Run_flag==1)
			{
			if(ToTargetStop_flag==0)
				{
				if(Backward_flag==1)     //后退
					{
					if(BackStop_flag==0)
						{
						if(TargetSize<CurrentSize)
							{
							temp=CurrentSize-TargetSize;
							if(temp>100) //后退停止
								{
								//SetMotorSpeed(5); 
								MoveStop();
								if(ForceStop_flag==0)
									{
									BackStop_flag=1;
									stop_time=0;
									}
								else  //手动 停止
									{
									Backward_flag=0;
									Run_flag=0;
									ForceStop_flag=0;
									}
								}
							}
						}
					}
				else if(Forward_flag==1)  //前进
					{
					//if(CurrentSize<TargetSize+VirtualTargetSizeGap)
						///{
						//temp=CurrentSize-TargetSize;
						//}
					//else	
						//{
						//temp=TargetSize-CurrentSize;
					//	}
					if(CurrentSize<TargetSize+Aheader)    //停止运行
						{
						MoveStop();
						Forward_flag=0;
						Run_flag=0;
						ForceStop_flag=0;
						//RunStop_flag=1;
						stop_time=0;
						   
						ToTargetStop_flag=1;
						SelfLockEn_flag=1;
						StopDelay_flag=1;
						StopDelayCou=0;
						FreqMotorStop_flag=0;
					    StopMotorExec();
						}
					}
				}
				
			}
		
		if(SelfLockEn_flag==1)  
					{
					if(Wheel_limit==1)
						{
						SelfLockEn_flag=0;//自锁 取消
						ToTargetStop_flag=0;
						TargetSize=0;
						BeforeKnife_offset_in=0;
						InTargetPosit_flag=0;	//清目标 标志
						
						MoveStop();
						ForceStop_flag=0;
						BackStop_flag=0;
						Backward_flag=0;
						Forward_flag=0;
						Run_flag=0;
						AutoPushRun_flag=0;
						}
					}
					
					
		if(ToTargetStop_flag==1)	//到目标停止后
			{
			if(SelfLockEn_flag==1)
				{
				if(StopDelay_flag==1)
					{
					StopDelayCou++;
					if(StopDelayCou>4000)//0.2s
						{
						StopDelay_flag=0;
						}
					}
				else
					{
					if(TargetSize<CurrentSize)
						{
						temp=CurrentSize-TargetSize;
						if(temp>(VirtualTargetSizeGap-5))  //继续  低速  前进
							{
							//if(Forward_flag==0)
								//{
								MoveForward();//前进
								//Forward_flag=1;
								//}
							//if(MoveSpeed!=4)  //低速 
								//{
								MoveSpeed=4;
								SetMotorSpeed(MoveSpeed);
								//}
							FreqMotorStop_flag=0;
							InTargetPosit_flag=0;	//清目标 标志
							}
						else
							{
							if(FreqMotorStop_flag==0)
								{
								MoveStop();             //完全停止
								Forward_flag=0;
								ForceStop_flag=0;
								RunStop_flag=1;
								stop_time=0;
								FreqMotorStop_flag=1;
								if(MotorType==MOTOR_FREQ_3_SPD)
									SelfLockEn_flag=0;
								}
							
							//ToTargetStop_flag=0;
							}
						}
					else	
						{
						temp=TargetSize-CurrentSize;
						if(temp>(VirtualTargetSizeGap-5))  //继续  低速  后退
							{
							//if(Backward_flag==0)
							//	{
								MoveBack();  //后退
							//	Backward_flag=1;
							//	}
							//if(MoveSpeed!=4)  //低速 
							//	{
								MoveSpeed=4;
								SetMotorSpeed(MoveSpeed);
							//	}
							FreqMotorStop_flag=0;
							InTargetPosit_flag=0;	//清目标 标志
							}
						else
							{
							if(FreqMotorStop_flag==0)
								{
								MoveStop();
								Backward_flag=0;
								ForceStop_flag=0;
								RunStop_flag=1;
								stop_time=0;
								FreqMotorStop_flag=1;
								if(MotorType==MOTOR_FREQ_3_SPD)
									SelfLockEn_flag=0;
								}
						   
							//ToTargetStop_flag=0;
							}
						}
					}
				}
			else
				{
				if(InTargetPosit_flag==1)
					{
					if(CurrentSize>TargetSize)
						{
						temp=CurrentSize-TargetSize;
						}
					else
						{
						temp=TargetSize-CurrentSize;
						}
					if(temp>=(VirtualTargetSizeGap-0))  //超出误差值
						{
						InTargetPosit_flag=0;
						}
					}
				
				}
			
			}
			
			
			break;
	// // case MOTOR_DC_SERVO:
		
			// // break;
	case MOTOR_AC_SERVO:
	case MOTOR_AC_SERVO_REV:
			if(OIN1_PIN)   //如果第一路光藕输入为高?
				{  
				senor=1;
				}
			 
			if(!OIN1_PIN)   //如果第一路光藕输入为高?
				{
				senor=0;
				}
		if((ElectricWheelOn_flag==1)&&(Run_flag==0))
			{
			// if((AllPressUp_flag==1)&&(AllKnifeUp_flag==1))
			if(1)		//20191115
				{
				 if(OIN6_PIN)   //如果第一路光藕输入为高?
					{
					xa1=1;
					}
				
				 if(OIN7_PIN)   //如果第一路光藕输入为高?
					{  
					xb1=1;
					}
					
				 if(!OIN6_PIN)   //如果第一路光藕输入为高?
					{
					xa1=0;
					}
				
				 if(!OIN7_PIN)   //如果第一路光藕输入为高?
					{
					xb1=0;
					}    
				   
				//if(flagshoulun==0) 
					if(xa==1&&xb==1)  
						{ 
						 if(xa1==0&&xb1==1)
							{ 
							InTargetPosit_flag=0;
							if(MotorType==MOTOR_AC_SERVO)
								M_DOUT_OFF ;
							else
								M_DOUT_ON ;
						  
							  i=500;
							  while(i--);
							  
							  M_POUT_ON ;
							  i=500;
							  while(i--);
							  M_POUT_OFF ;
							  houtuicn=houtuicn+1; 
							}
						}
						  
					if(xa==0&&xb==0)  
						{ 
						if(xa1==1&&xb1==0)
							{ 
							InTargetPosit_flag=0;
							if(MotorType==MOTOR_AC_SERVO)
								M_DOUT_OFF ;
							else
								M_DOUT_ON ;
						   //    M_POUT_ON ;
							//   i=500;
							// while(i--);
							//  M_POUT_OFF ;
							//  houtuicn=houtuicn+1;      
							  
							  i=500;
							  while(i--);
							  
							  M_POUT_ON ;
							  i=500;
							  while(i--);
							  M_POUT_OFF ;
							  houtuicn=houtuicn+1; 
							}
							
						}
						  
					if(xa==0&&xb==1)
					   {
					   if(xa1==1&&xb1==1)
						 {       
							InTargetPosit_flag=0;
							if(MotorType==MOTOR_AC_SERVO)
								M_DOUT_ON ;
							else 
								M_DOUT_OFF;
							
						  
								i=500;
							  while(i--);
							  
							   M_POUT_ON ;
							   i=500;
							  while(i--);
							  M_POUT_OFF ;
							  qianjincn=qianjincn+1; 
						 }
					   }
							 
					if(xa==0&&xb==0)
						{
						 if(xa1==0&&xb1==1)
							{ 
							InTargetPosit_flag=0;
							if(MotorType==MOTOR_AC_SERVO)
								M_DOUT_ON ;
							else 
								M_DOUT_OFF;
							 //  M_POUT_ON ;
							//   i=500;
							 ////  while(i--);
							 //  M_POUT_OFF ;
							 //  qianjincn=qianjincn+1;   
						  
								i=500;
							  while(i--);
							  
							   M_POUT_ON ;
							   i=500;
							  while(i--);
							  M_POUT_OFF ;
							  qianjincn=qianjincn+1; 
							}
						}
						 
					xa=xa1;
					xb=xb1;    
				}
			}
		
			break;		
	}
     
          
  MsTime++;
  if(MsTime>=20)
	{
	 MsTime=0;
	 Ms_Flag=1;
	 SysTime++;
        
         chengxuTime++;
         
         sys_tick++;
         
         if( flaglaba==1)
            {
            labatime++;
             if(labatime>200)
               {
               labatime=0;
               flaglaba=0;
               BellOUT_OFF;
               }
             }
         
          
        if(CutEnBegin_flag==1)
			{
			CutDelayTime++;
			if(CutDelayTime>400)
				{
				CutEnBegin_flag=0;
				BellOUT_OFF;
				RLOUT4_ON;
						AutoCutStart_flag=0;
						RunStop_flag=0;
						Run_flag=0;
						
				}
				
			}
		
        /*
         if( chengxuTime>300)
         {
            chengxuTime=0;
            chengxu_Flag=!chengxu_Flag;
           
           
         } 
         
       xianshitime++;
         if( xianshitime>3000)
         {
             xianshitime=0;
            xianshi_Flag=!xianshi_Flag;
           
           
         }
        
		 */
	 if(SysTime>=10)
		{
		 SysTime=0;
                //// Bcd[3]++;
	       // if(Bcd[3]>9)
		// Bcd[3]=0;

                 sysflag=1;
                 
                 
		}
	}
  //VICADDRESS = 0;
}

void Timer0Init(void)
{

	Timer0_Config();

////  TMR_PSCALE_SETUP_T pscale;
////  TMR_MATCH_SETUP_T msetup;

////  int_install_irq_handler(IRQ_TIMER0, (PFV) Timer0IntrHandler);


////  timer0dev = timer_open(TIMER_CNTR0, 0);


////  pscale.ps_tick_val = 0; /* Use ps_us_val value */
////  pscale.ps_us_val = 25; /* 100uS */
////  timer_ioctl(timer0dev, TMR_SETUP_PSCALE, (INT_32) &pscale);


////  msetup.timer_num = 0; /* Use match register set 0 (of 0..3) */
////  msetup.use_match_int = TRUE; /* Generate match interrupt on match */
////  msetup.stop_on_match = FALSE; /* Do not stop timer on match */
////  msetup.reset_on_match = TRUE; /* Reset timer counter on match */
////  msetup.match_tick_val = 1; /* Match is when timer count is 1000 */
////  timer_ioctl(timer0dev, TMR_SETUP_MATCH, (INT_32) &msetup);


////  timer_ioctl(timer0dev, TMR_CLEAR_INTS,
////              (TIMER_CNTR_MTCH_BIT(0) | TIMER_CNTR_MTCH_BIT(1) |
////               TIMER_CNTR_MTCH_BIT(2) | TIMER_CNTR_MTCH_BIT(3) |
////               TIMER_CNTR_CAPT_BIT(0) | TIMER_CNTR_CAPT_BIT(1) |
////               TIMER_CNTR_CAPT_BIT(2) | TIMER_CNTR_CAPT_BIT(3)));
////  /******************************************************************/
////  T0TCR_bit.CE = 1;     // counting Enable
////  //timer_ioctl(timer0dev, TMR_ENABLE, 1);


////  /* Enable timer interrupts in the interrupt controller */
////  int_enable(IRQ_TIMER0);

}

void Timer0Disable(void)  //定时器0禁止
{
//		timer_close(timer0dev);
		ETimer0_Close();
//// T0TCR_bit.CE = 0;     // counting Enable
//// /*
//// VICINTENCLEAR |= 1UL << VIC_TIMER0;
//// */
}


void Timer1IntrHandler(void)
{
  unsigned long int i;
//user code start
  //WDFEED = 0xaa;
 // WDFEED = 0x55;
   //T1MR1 = SYS_GetFpclk(TIMER1_PCLK_OFFSET)/(TIMER1_TICK_PER_SEC);
//user code end
  // clear interrupt
////  T1IR_bit.MR1INT = 1;
    Ms_Flag=1;
  if(houtui==1)
	{     
    qianjin=0;  
	if(WorkStart_flag==1)
		{
		if((GoFrontEn_flag==1)||(GoBackEn_flag==1))
			{
			outpw(REG_ETMR1_CMPR,(0xffff- JogTable[step_add]));	
			}
		else
			{
			outpw(REG_ETMR1_CMPR,(0xffff- waitTemp[step_add]));	//T1MR1 =(0xffff- waitTemp[step_add]);
			}	
		}
	else
		outpw(REG_ETMR1_CMPR,(0xffff- waitTb88[step_add]));//T1MR1 =(0xffff- waitTb4[step_add]);
	
	if(MotorType==MOTOR_AC_SERVO)
		M_DOUT_OFF ;
    else
		M_DOUT_ON ;
		
    M_POUT_ON ;
    i=50;
    while(i--);
    M_POUT_OFF ;
     
	houtuicn=houtuicn+1; 
  
    }
  
  if(qianjin==1)
	{     
    houtui=0;  
	if(WorkStart_flag==1)
		{
		if((GoFrontEn_flag==1)||(GoBackEn_flag==1))
			{
			outpw(REG_ETMR1_CMPR,(0xffff- JogTable[step_add]));	
			}
		else
			{
			outpw(REG_ETMR1_CMPR,(0xffff- waitTemp[step_add]));	//T1MR1 =(0xffff- waitTemp[step_add]);
			}	
		}
	else
		outpw(REG_ETMR1_CMPR,(0xffff- waitTb88[step_add]));//T1MR1 =(0xffff- waitTb4[step_add]);
	    
    if(MotorType==MOTOR_AC_SERVO)
		M_DOUT_ON ;
    else
		M_DOUT_OFF ;
    
    M_POUT_ON ;
    i=50;
    while(i--);
    M_POUT_OFF ;
     
	qianjincn=qianjincn+1; 
  
    }
   
 if(status==9)         
   {
    rollsteps=rollsteps-1;
    if(rollsteps==0)
		{
        flagtingji8=1;
        flagyunxing8=0; 
       
         status=8; 
       //  flagtingji7=1;
        t0zhongduan=0;
    
        keytingji=0;
    
        Timer1Disable();
         
       }
   }
  
 if(status==1)         //加速阶段
   {
     step_ground--;
     if(step_ground==0)
       {
        step_ground=11;
        step_add++;
        speedup_steps--;
        if(speedup_steps==0)
          {
   //          rollsteps--;
             status=2;
          }
        
       }
 
   
   }
  
  if(status==2)
   {  
    if(flagqyx==0)
      {
       rollsteps=rollsteps-1;
       step_add= speedup_steps_B;
       if(rollsteps==0)
		{
         speedup_steps=speedup_steps_B;
         step_ground=11;
         status=4;
		}
      }
   
   }
  
  if(status==4)
  {
   step_ground=step_ground-1;;    
   if(step_ground==0)
     {
      step_ground=11;
      step_add--;
      
      speedup_steps--;
      
      
      if(speedup_steps==0)
       {
         status=8; 
       
         flagtingji8=1;     
          flagyunxing8=0; 
         t0zhongduan=0;
         flagone=0;
   ///////////////////////////////////// 
       Timer1Disable();
       if(qianjin==1)
       {
       flagbeep=1;
       }
       //  Timer0Init();
       }
     
     }
  
  }
  
  
  
 if(flaglaba==1)
        {
        labatime++;
        if(labatime>1200)
               {
               labatime=0;
               flaglaba=0;
               BellOUT_OFF;
               }
        } 
  /*
 T1MR1 =(0xffff- waitTb8[10]);
 
   M_DOUT_OFF ;
   
   M_POUT_ON ;
   i=500;
 while(i--);
   M_POUT_OFF ;
  */		
  //VICADDRESS = 0;

}

void Timer1Init(void)
{
Timer1_Config();
	
////  TMR_PSCALE_SETUP_T pscale;
////  TMR_MATCH_SETUP_T msetup;
/////* Install timer interrupts handlers as a IRQ interrupts */


//////user code start
//// //user code end
////  // Enable TIM0 clocks
//////  PCONP_bit.PCTIM1 = 1; // enable clock

////    int_install_irq_handler(IRQ_TIMER1, (PFV) Timer1IntrHandler);

////  /* Open timers - this will enable the clocks for all timers when
////     match control, match output, and capture control functions
////     disabled. Default clock will be internal. */

////  timer1dev = timer_open(TIMER_CNTR1, 0);


////  // Init Time0
////  T1TCR_bit.CE = 0;     // counting  disable
////  T1TCR_bit.CR = 1;     // set reset
////  T1TCR_bit.CR = 0;     // release reset
////  T1CTCR_bit.CTM = 0;   // Timer Mode: every rising PCLK edge
////  T1MCR_bit.MR1I = 1;   // Enable Interrupt on MR0
////  T1MCR_bit.MR1R = 1;   // Enable reset on MR0
////  T1MCR_bit.MR1S = 0;   // Disable stop on MR0
////  // set timer 0 period
////  T1TC=0;
////  T1PR = 0;
////  T1MR1 = (0xffff- waitTemp[0]);//SYS_GetFpclk(TIMER1_PCLK_OFFSET)/(TIMER1_TICK_PER_SEC);
////  // init timer 0 interrupt
////  T1IR_bit.MR1INT = 1;  // clear pending interrupt
//////  VIC_SetVectoredIRQ(Timer1IntrHandler,TIMER1_PRIORITY,VIC_TIMER1);
//////  VICINTENABLE |= 1UL << VIC_TIMER1;
/////*
////  T1TCR_bit.CE = 1;     // counting Enable
////  __enable_interrupt();

////  */

////  /******************************************************************/
////  /* Setup timer 0 for a 10Hz match rate                            */

//////  timer_ioctl(timer1dev, TMR_ENABLE, 1);
////  
////  T1TCR_bit.CE = 1;     // counting Enable

////  /* Enable timer interrupts in the interrupt controller */
////  T1TC=0;
////  int_enable(IRQ_TIMER1);

}


void Timer1Disable(void)  //定时器1禁止
{
//	timer_close(timer1dev);
	ETimer1_Close();
//// T1TCR_bit.CE = 0;     // counting Enable
//// /*
//// VICINTENCLEAR|= 1UL << VIC_TIMER1;
//// */
}



//-------------------------------------------------------
void ACServoMoveBack_MID_SPD(void)  //交流伺服  中速后退
{
 houtui=1;
qianjin=0;   

step_add=10;   

step_ground=11; 

speedup_steps=40;
status=1;
 flagqyx=2;
 
Timer1Init();
Timer0Disable(); 
//BellOUT_OFF;

RLOUT1_ON; RLOUT1_1_ON;   // 允许裁切断开
AutoPress_Stop();	//断 自动压，允许压 20191108
EnblePress_Stop();
CutPermit_flag=0;
}
void ACServoMoveFwd_MID_SPD(void)  //交流伺服  中速前进
{
 houtui=0;
qianjin=1;   

step_add=10;   

step_ground=11; 

speedup_steps=40;
status=1;
 flagqyx=2;
 
Timer1Init();
Timer0Disable(); 
//BellOUT_OFF;

RLOUT1_ON; RLOUT1_1_ON;   // 允许裁切断开
AutoPress_Stop();	//断 自动压，允许压 20191108
EnblePress_Stop();
CutPermit_flag=0;
}

void ACServoMoveBack_LOW_SPD(void)  //交流伺服  低速后退
{
step_add=30;
step_ground=11; 
speedup_steps=40;  

status=4;   

 Timer1Init();
Timer0Disable(); 
//BellOUT_OFF;

RLOUT1_ON; RLOUT1_1_ON;   // 允许裁切断开
AutoPress_Stop();	//断 自动压，允许压 20191108
EnblePress_Stop();
CutPermit_flag=0;
}

void ACServoStop(void)  //交流伺服	停止
{
flagtingji8=1;     
flagyunxing8=0; 
t0zhongduan=1;//0;
flagone=0;
flagqyx=0;
Timer1Disable();
Timer0Init(); 
if(flagyd==1)
	{
	 flagyd=0;
	}
	
RunStop_flag=0;
LowerAC_SPD_flag=0;

stop_time=0;
Run_flag=0;	
if(ACServoDrvErr_flag==0)
	{
	// RLOUT1_OFF; RLOUT1_1_OFF;   // 允许裁切-----------------20191108
	}
}



/*
void ExtInt1IntrHandler(void)  //外部中断ISR
{

  WDFEED = 0xaa;
  WDFEED = 0x55;

  
    
   Timer1Disable();
dem++;
Temp11++;
 status=12;
 poweon_flag=0;
 chushihua=1;
  qianjincn=0;
   houtuicn=0; 
  flagtingji8=1; 
    houtui=0;
    qianjin=1;
 
muqiancn=yuandiancn;


 IO2INTENF&=~(1<<11);//关中断

  
  VICADDRESS = 0;
}
*/

void ExtInt1Init(void)  //外部中断初始化
{
  /*
  PINSEL4 &= ~(1<<22|1<<23);//
  PINSEL4 |= (1<<22|0<<23);

  
  
FIO2DIR&=~(1<<11);
  IO2INTENF&=~(1<<11);//关中断

VICINTENCLEAR |= 1<< VIC_EINT3;
VIC_SetVectoredIRQ(ExtInt1IntrHandler,0,VIC_EINT3);  //开外部1中断  最高优先级
VICINTENABLE |= 1<< VIC_EINT3;
__enable_interrupt();
*/
}

/*
void ExtInt1IntrHandler(void)  //外部中断ISR
{

	 EXTINT|=(1<<EINT1); //清除标志位 
	 Bcd[3]++;
	 if(Bcd[3]>9)
		 Bcd[3]=0;
  VICADDRESS = 0;
}


void ExtInt1Init(void)  //外部中断初始化
{
EXTMODE=(1<<EXTMODE1);    //EINT1 边沿触发
EXTPOLAR=(1<<EXTPOLAR1); //EINT1  下降沿有效
VIC_SetVectoredIRQ(ExtInt1IntrHandler,0,VIC_EINT1);  //开外部1中断  最高优先级
VICINTENABLE |= ( 1<< VIC_EINT1);
__enable_interrupt();
}

*/









void AC_ChangeSPD(void)  
{
if(flagqyx==1)
	{
	 step_add=10;      
	  step_ground=11; 

	  speedup_steps=30;
	  status=1;      
	  houtui=0; 
	}    
}

void ACMotorRunStart(Int32U vbcd)//  AC伺服  运行启动
{    
Int32U tempqianjin1;    
Int32U temphoutui1;    
if(vbcd<CurrentSize)
	{ 
	if(MotorType == MOTOR_AC_SERVO)	//	20190523
		{
		tempqianjin1=(CurrentSize-vbcd)*2;		
		}
	else
		{
		tempqianjin1=(CurrentSize-vbcd);	
		}
	
    rollsteps=tempqianjin1-yushu;
    qianjin=1;
    houtui=0;  
	
	RLOUT1_ON; RLOUT1_1_ON;   // 允许裁切断开
	AutoPress_Stop();	//断 自动压，允许压 20191108
	EnblePress_Stop();
	AirSwitch_Work();// 气阀闭合
	CutPermit_flag=0;
	}  
else if(vbcd>CurrentSize)
    {
	if(MotorType == MOTOR_AC_SERVO)	//	20190523
		{
		temphoutui1=(vbcd-CurrentSize)*2;		
		}
	else
		{
		temphoutui1=(vbcd-CurrentSize);// 
		}
	 rollsteps=temphoutui1+yushu;
	 houtui=1;
	 qianjin=0;
	 
	RLOUT1_ON;RLOUT1_1_ON;    // 允许裁切断开
	AutoPress_Stop();	//断 自动压，允许压 20191108
	EnblePress_Stop();
	AirSwitch_Work();// 气阀闭合
	CutPermit_flag=0; 
    }  
else
    {
	qianjin=0;
    houtui=0;
	}   
          
if(houtui==1)
    {     
	step_ground=11; 
	rollsteps=rollsteps+ACSERVER_BACK_OFFSET;    
        
	if(rollsteps>3000)
		{
	   speedup_steps=100;  
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;      
		
		}
	else if(rollsteps>2000&&rollsteps<3001)
		{  
		speedup_steps=45; 
		speedup_steps_B=speedup_steps;
		rollsteps=(rollsteps- speedup_steps*22)+2;
		status=1;  
		  
		
		}                                                               
	else if(rollsteps>1000&&rollsteps<2001)
		{
	   speedup_steps=30; 
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;  
						
		} 
	else if(rollsteps>500&&rollsteps<1001)
		{
	   speedup_steps=20;
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;  
					
		}   
	else  if(rollsteps>100&&rollsteps<501)
		{
		speedup_steps=4;   
		speedup_steps_B=speedup_steps;
		rollsteps=(rollsteps- speedup_steps*22)+2;
		status=1;  
			
		}
	else
		{  
		   status=9;    
		   step_add=1;  
		   
	 //       speedup_steps=1;
		}
          
	flagtingji8=0;
	flagyunxing8=1;
	step_add=1;     

	Timer1Init();
	Timer0Disable();
    }  
            
            
if(qianjin==1)//----------------------------------------------------------
    {
     step_ground=11;  
  
	if(rollsteps>3000)
		{
	   speedup_steps=100;  
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;  
	  
		}
	else if(rollsteps>2000&&rollsteps<3001)
		{
		speedup_steps=45;
		speedup_steps_B=speedup_steps;
		rollsteps=(rollsteps- speedup_steps*22)+2;
		status=1;   
	   
		}
	else if(rollsteps>1000&&rollsteps<2001)
		{
	   speedup_steps=30;
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;   
				
		} 
	else if(rollsteps>500&&rollsteps<1001)
		{
	   speedup_steps=20;
	   speedup_steps_B=speedup_steps;
	   rollsteps=(rollsteps- speedup_steps*22)+2;
	   status=1;   
				  
		}   
	else  if(rollsteps>100&&rollsteps<501)
		{
		speedup_steps=4;  
		speedup_steps_B=speedup_steps;
		rollsteps=(rollsteps- speedup_steps*22)+2;
		status=1;  
		 
		}
	else
		{    
		status=9; 
		step_add=1;  
		 
	 //       speedup_steps=1;
		}
	
	 flagtingji8=0;     
	 flagyunxing8=1;
	 step_add=1;     

	Timer1Init();
	Timer0Disable();
	
	}
    
}


void ACMotorGoForward(void)  //前进
{
flagyd=1;       
flagqyx=1;

qianjin=1;

step_add=25;      
step_ground=11; 

speedup_steps=30;
status=1;      
houtui=0; 
 
flagtingji8=0;
flagyunxing8=1;      

Timer1Init();
Timer0Disable();

RLOUT1_ON; RLOUT1_1_ON;  // 允许裁切断开
AutoPress_Stop();	//断 自动压，允许压 20191108
EnblePress_Stop();
AirSwitch_Work();// 气阀闭合
CutPermit_flag=0;
}

void ACMotorGoBack(void)  //后退
{   
 qianjin=0;
flagqyx=2;
 flagyd=1;

step_add=25;   
step_ground=11; 

speedup_steps=30;
houtui=1; 
status=1;

flagtingji8=0;
flagyunxing8=1;  

Timer1Init();
Timer0Disable();

RLOUT1_ON; RLOUT1_1_ON;   // 允许裁切断开
AutoPress_Stop();	//断 自动压，允许压 20191108
EnblePress_Stop();
AirSwitch_Work();// 气阀闭合
CutPermit_flag=0;
}

void ACMotorGoFastForward(void)  // 快进
{
flagyd=1;       
flagqyx=1;

qianjin=1;

step_add=80;//60;      
step_ground=11; 

speedup_steps=30;
status=1;      
houtui=0; 
 
flagtingji8=0;
flagyunxing8=1;      

Timer1Init();
Timer0Disable();

RLOUT1_ON; RLOUT1_1_ON;   // 允许裁切断开
AutoPress_Stop();	//断 自动压，允许压 20191108
EnblePress_Stop();
AirSwitch_Work();// 气阀闭合
CutPermit_flag=0;
}

void ACMotorGoFastBack(void)  //快退
{   
 qianjin=0;
flagqyx=2;
 flagyd=1;

step_add=80;//60;   
step_ground=11; 

speedup_steps=30;
houtui=1; 
status=1;

flagtingji8=0;
flagyunxing8=1;  

Timer1Init();
Timer0Disable();

RLOUT1_ON; RLOUT1_1_ON;   // 允许裁切断开
AutoPress_Stop();	//断 自动压，允许压 20191108
EnblePress_Stop();
AirSwitch_Work();// 气阀闭合
CutPermit_flag=0;
}


void ACMotor_ReleaseStop(void)
{
flagkey=0;
flagkeysong=1;
// flagyici=0;
 flagtime1=0;
flagyunxing8=0;

/*
if(flagyd==1)
	{
	 flagyd=0;
	 
	   flagzhiyou=0;
	   flagtingji8=1;
	   flagyunxing8=0;
	  // keytingji=0;
	   flagqyx=0;
  
	  flagtingji8=1;
   
	 Timer1Disable();
	 Timer0Init();
	}
	*/
}



//******************************************
